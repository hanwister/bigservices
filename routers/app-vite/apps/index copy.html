<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Monaco Editor with Custom Completions</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        #editor {
            height: 70vh;
            border-radius: 0.5rem;
            overflow: hidden;
        }
        .container {
            border: 1px solid #4B5563; /* Add border for the container */
            border-radius: 0.5rem;
            padding: 1rem;
            background-color: #1F2937; /* Background color for the container */
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-200 min-h-screen p-4 flex flex-col items-center">

    <div class="w-full max-w-4xl mb-4">
        <h1 class="text-2xl font-bold mb-2 text-white">Trình soạn thảo Monaco tùy chỉnh</h1>
        <p class="mb-4 text-gray-400">Thêm các biến mới dưới đây để xem gợi ý tự động được cập nhật.</p>
        <div class="flex flex-col sm:flex-row space-y-2 sm:space-y-0 sm:space-x-4 mb-4">
            <input
                id="variableName"
                type="text"
                class="flex-1 p-2 rounded-md bg-gray-800 text-white border border-gray-700 focus:outline-none focus:ring-2 focus:ring-blue-500"
                placeholder="Tên biến (ví dụ: myData)"
            />
            <input
                id="variableDescription"
                type="text"
                class="flex-1 p-2 rounded-md bg-gray-800 text-white border border-gray-700 focus:outline-none focus:ring-2 focus:ring-blue-500"
                placeholder="Mô tả (tùy chọn)"
            />
            <button
                id="addVariableBtn"
                class="px-4 py-2 rounded-md bg-blue-600 hover:bg-blue-700 transition-colors duration-200 text-white font-semibold"
            >
                Thêm biến  
            </button>
        </div>
    </div>

    <div class="w-full max-w-4xl">
        <div id="editor"></div>
        <div class="container mt-4">
            <div class="flex flex-col space-y-4">
                <div class="p-4 bg-gray-700 rounded-md">
                    <p class="text-gray-300">
                        <span class="text-blue-400 font-bold">Lưu ý:</span>
                        Đây là một ví dụ về cặp thẻ div và p. Bạn có thể sử dụng các lớp CSS của Tailwind để tạo kiểu cho các thẻ này.
                    </p>
                </div>
                <div class="p-4 bg-gray-700 rounded-md">
                    <p class="text-gray-300">
                        <span class="text-blue-400 font-bold">Chú ý:</span>
                        Các thẻ này được thêm trực tiếp vào HTML. Để sử dụng trong một framework như React, bạn sẽ cần tạo các thành phần JSX tương ứng.
                    </p>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/monaco-editor@0.41.0/min/vs/loader.js"></script>
    
    <script>
        // Use require.js to load the Monaco core library
        require.config({ paths: { 'vs': 'https://cdn.jsdelivr.net/npm/monaco-editor@0.41.0/min/vs' }});

        // Predefined variables
        let allVariables = [
            { name: 'userData', description: 'Thông tin người dùng hiện tại.', insertText: 'userData' },
            { name: 'productData', description: 'Dữ liệu sản phẩm.', insertText: 'productData' },
            { name: 'apiResponse', description: 'Phản hồi từ API.', insertText: 'apiResponse' },
            { name: '$global', description: 'Biến toàn cục.', insertText: '$global' },
            { 
              name: '$local', 
              description: 'Biến cục bộ với cấu trúc JSON.', 
              insertText: '{\n  "tsd": "dfdsf",\n  "test": "dfsdf",\n  "pp": {\n    "dfds": 4564\n  }\n}' ,
              data: {
                tsd: "dfdsf",
                test: "dfsdf",
                pp: {
                    dfds: 4564
                }
              }
            },
            { name: '$stream', description: 'Dữ liệu luồng.', insertText: '$stream' },
            { name: '$env', description: 'Biến môi trường.', insertText: '$env' },
            { 
              name: '$config', 
              description: 'Cấu hình ứng dụng với cấu trúc JSON.', 
              insertText: '{\n  "sadd": {\n    "dfsdf": {\n      "dfsdf": 45345\n    }\n  }\n}',
              data: {
                sadd: [{
                  dfsdf: {
                    dfsdf: 45345
                  }
                },24234,2342, {fsdf:"dsfsdf"}]
              }
            },
            { name: '$utils', description: 'Hàm tiện ích.', insertText: '$utils' },
            { name: '$http', description: 'Thư viện HTTP.', insertText: '$http' },
            { name: '$auth', description: 'Thông tin xác thực.', insertText: '$auth' },
            { name: '$db', description: 'Kết nối cơ sở dữ liệu.', insertText: '$db' },
            { name: '$cache', description: 'Hệ thống cache.', insertText: '$cache' },
            { name: 'userProfile', description: 'Hồ sơ người dùng với cấu trúc JSON.', insertText: '{\n  "name": "John Doe",\n  "age": 30,\n  "email": "john.doe@example.com"\n}' }
        ];
        
        // The ID of the completion provider for disposal
        const COMPLETION_PROVIDER_ID = 'my-custom-completion-provider';
        let completionProvider = null;

        function getVariableValue(path) {
            const parts = path.split(/[\.\[\]]+/).filter(part => part !== '');
            if (parts.length === 0) return null;
            
            let baseVar = allVariables.find(v => v.name === `$${parts[0]}`);
            if (!baseVar) return null;
            
            let current = baseVar.data;
            for (let i = 1; i < parts.length; i++) {
                const part = parts[i];
                if (!current || typeof current !== 'object') {
                    return null;
                }
                current = current[part];
            }
            return current;
        }

        function getNestedProperties(obj, pathParts) {
            let current = obj;
            for (let i = 0; i < pathParts.length; i++) {
                const part = pathParts[i];
                if (!current || typeof current !== 'object') {
                    return null;
                }
                
                const arrayMatch = part.match(/^\[(\d+)\]$/);
                const variableMatch = part.match(/^\[\s*(\$[a-zA-Z_]+\.[a-zA-Z0-9_]+)\s*\]$/);

                if (arrayMatch) {
                    const index = parseInt(arrayMatch[1], 10);
                    if (Array.isArray(current) && index < current.length) {
                        current = current[index];
                    } else {
                        return null;
                    }
                } else if (variableMatch) {
                    const variablePath = variableMatch[1];
                    const key = getVariableValue(variablePath);
                    if (key !== null && typeof key === 'string' && current.hasOwnProperty(key)) {
                        current = current[key];
                    } else {
                        return null;
                    }
                } else {
                    current = current[part];
                }
            }
            return current;
        }

        function setupVariableCompletionProvider() {
            if (completionProvider) {
                completionProvider.dispose();
            }

            completionProvider = monaco.languages.registerCompletionItemProvider('html', {
                provideCompletionItems: (model, position) => {
                    const textUntilPosition = model.getValueInRange({
                        startLineNumber: position.lineNumber,
                        startColumn: 1,
                        endLineNumber: position.lineNumber,
                        endColumn: position.column
                    });

                    if (textUntilPosition.endsWith('$')) {
                        const range = {
                            startLineNumber: position.lineNumber,
                            endLineNumber: position.lineNumber,
                            startColumn: position.column,
                            endColumn: position.column,
                        };
                        const suggestions = allVariables.filter(v => v.name.startsWith('$')).map(v => ({
                            label: {
                                label: v.name,
                                description: v.description
                            },
                            kind: monaco.languages.CompletionItemKind.Variable,
                            documentation: v.description,
                            insertText: v.name.substring(1),
                            range: range,
                        }));
                        return { suggestions: suggestions };
                    }
                    
                    let match = textUntilPosition.match(/([a-zA-Z_$][a-zA-Z0-9_]*|\$[a-zA-Z_]+)(?:\.[a-zA-Z0-9_]*|\[[^\]]*\])*\.?$/);
                    let suggestions = [];

                    if (match) {
                        const fullPath = match[0].endsWith('.') ? match[0].slice(0, -1) : match[0];
                        const pathParts = fullPath.split(/[\.\[\]]+/).filter(part => part !== '');
                        const baseVarName = pathParts[0];

                        let baseVariable = allVariables.find(v => v.name === baseVarName);
                        
                        if (!baseVariable) {
                            const modelLines = model.getLinesContent();
                            for (let i = position.lineNumber - 1; i >= 0; i--) {
                                const line = modelLines[i];
                                const assignmentMatch = line.match(new RegExp(`const\\s+${baseVarName}\\s*=\\s*(\\$[a-zA-Z_]+);`));
                                if (assignmentMatch && assignmentMatch[1]) {
                                    baseVariable = allVariables.find(v => v.name === assignmentMatch[1]);
                                    break;
                                }
                            }
                        }

                        if (baseVariable && baseVariable.data) {
                            const parts = fullPath.match(/([a-zA-Z_$][a-zA-Z0-9_]*|\[[^\]]*\])/g);
                            if (parts) {
                                let currentObject = baseVariable.data;
                                for (let i = 1; i < parts.length; i++) {
                                    let part = parts[i];
                                    if (part.startsWith('[')) {
                                        const innerMatch = part.match(/^\[\s*(\$[a-zA-Z_]+\.[a-zA-Z0-9_]+)\s*\]$/);
                                        if (innerMatch) {
                                            const variablePath = innerMatch[1];
                                            const key = getVariableValue(variablePath);
                                            if (key !== null && typeof key === 'string' && currentObject.hasOwnProperty(key)) {
                                                currentObject = currentObject[key];
                                            } else {
                                                currentObject = null;
                                                break;
                                            }
                                        } else {
                                            const indexMatch = part.match(/^\[(\d+)\]$/);
                                            if (indexMatch && Array.isArray(currentObject)) {
                                                const index = parseInt(indexMatch[1], 10);
                                                currentObject = currentObject[index];
                                            } else {
                                                currentObject = null;
                                                break;
                                            }
                                        }
                                    } else {
                                        if (currentObject && typeof currentObject === 'object' && currentObject.hasOwnProperty(part)) {
                                            currentObject = currentObject[part];
                                        } else {
                                            currentObject = null;
                                            break;
                                        }
                                    }
                                }

                                if (currentObject && typeof currentObject === 'object') {
                                    const range = {
                                        startLineNumber: position.lineNumber,
                                        endLineNumber: position.lineNumber,
                                        startColumn: position.column,
                                        endColumn: position.column
                                    };

                                    if (Array.isArray(currentObject)) {
                                        suggestions = [{
                                            label: {
                                                label: 'length',
                                                description: 'Độ dài của mảng'
                                            },
                                            kind: monaco.languages.CompletionItemKind.Property,
                                            documentation: 'Trả về số phần tử trong mảng.',
                                            insertText: 'length',
                                            range: range,
                                        }];
                                    } else {
                                        suggestions = Object.keys(currentObject).map(key => ({
                                            label: {
                                                label: key,
                                                description: typeof currentObject[key] === 'object' ? 'Đối tượng' : typeof currentObject[key]
                                            },
                                            kind: typeof currentObject[key] === 'object' ? monaco.languages.CompletionItemKind.Folder : monaco.languages.CompletionItemKind.Variable,
                                            documentation: typeof currentObject[key] === 'object' ? 'Đối tượng lồng nhau.' : `Giá trị: ${JSON.stringify(currentObject[key])}`,
                                            insertText: key,
                                            range: range,
                                        }));
                                    }
                                }
                            }
                        }
                    } else {
                        const word = model.getWordUntilPosition(position);
                        const searchText = word.word.toLowerCase();
                        const filteredVariables = allVariables.filter(v => 
                            v.name.toLowerCase().includes(searchText) || 
                            v.description.toLowerCase().includes(searchText)
                        );
                        
                        const range = {
                            startLineNumber: position.lineNumber,
                            endLineNumber: position.lineNumber,
                            startColumn: word.startColumn,
                            endColumn: word.endColumn,
                        };

                        suggestions = filteredVariables.map(v => ({
                            label: {
                                label: v.name,
                                description: v.description
                            },
                            kind: monaco.languages.CompletionItemKind.Variable,
                            documentation: v.description,
                            insertText: v.insertText || v.name,
                            range: range,
                            filterText: `${v.name.toLowerCase()} ${v.description.toLowerCase()}`,
                        }));
                    }
                    return { suggestions: suggestions };
                },
                triggerCharacters: ['.', '[', '$'],
                id: COMPLETION_PROVIDER_ID,
            });
        }
        
        // Function to set up a simple HTML tag completion provider
        function setupHtmlCompletionProvider() {
            monaco.languages.registerCompletionItemProvider('html', {
                provideCompletionItems: (model, position) => {
                    const textUntilPosition = model.getValueInRange({
                        startLineNumber: position.lineNumber,
                        startColumn: 1,
                        endLineNumber: position.lineNumber,
                        endColumn: position.column
                    });

                    // Regex to find an unclosed tag at the end of the string
                    const matches = textUntilPosition.match(/<(\w*)$/);
                    if (!matches) {
                        return { suggestions: [] };
                    }

                    const suggestions = [
                        {
                            label: 'div',
                            kind: monaco.languages.CompletionItemKind.Snippet,
                            insertText: '<div>\n\t$0\n</div>', // Using a snippet with placeholder $0
                            insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
                            documentation: 'Tạo một cặp thẻ <div>.',
                        },
                        {
                            label: 'p',
                            kind: monaco.languages.CompletionItemKind.Snippet,
                            insertText: '<p>$0</p>',
                            insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
                            documentation: 'Tạo một cặp thẻ <p>.',
                        },
                        {
                            label: 'span',
                            kind: monaco.languages.CompletionItemKind.Snippet,
                            insertText: '<span>$0</span>',
                            insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
                            documentation: 'Tạo một cặp thẻ <span>.',
                        }
                        // Add more tags as needed
                    ];

                    const typedTag = matches[1];
                    const filteredSuggestions = suggestions.filter(s => s.label.startsWith(typedTag));
                    
                    // CORRECTED PART: Add 1 to matches.index to convert from 0-based index to 1-based column
                    const range = {
                        startLineNumber: position.lineNumber,
                        endLineNumber: position.lineNumber,
                        startColumn: matches.index + 1, // Corrected column start
                        endColumn: position.column
                    };
                    
                    // Map over filtered suggestions to apply the correct range
                    const finalSuggestions = filteredSuggestions.map(s => ({...s, range}));

                    return { suggestions: finalSuggestions };
                },
                triggerCharacters: ['<'],
            });
        }

        // Wait for the editor to be loaded
        window.onload = function() {
            require(['vs/editor/editor.main'], function() {
                // Initialize the editor
                const editor = monaco.editor.create(document.getElementById('editor'), {
                    value: `// Gõ "<" để xem gợi ý tự động hoàn thành cho các thẻ HTML như <div> và <p>.\n// Gõ "$" để xem gợi ý tự động hoàn thành cho các biến đã định nghĩa.\n\n<div className="my-component">\n    <p className="text-white">Chào mừng bạn đến với trình soạn thảo Monaco.</p>\n</div>`,
                    language: 'html', // Set the language to 'html'
                    theme: 'vs-dark',
                    minimap: { enabled: true },
                    fontSize: 14,
                    wordWrap: 'on',
                    roundedSelection: true,
                });
                
                // Set up the completion providers
                setupHtmlCompletionProvider();
                setupVariableCompletionProvider();
                
                // Add event listener for the button
                document.getElementById('addVariableBtn').addEventListener('click', () => {
                    const nameInput = document.getElementById('variableName');
                    const descInput = document.getElementById('variableDescription');
                    const newName = nameInput.value;
                    const newDesc = descInput.value || 'Biến tùy chỉnh.';

                    if (newName) {
                        allVariables.push({ name: newName, description: newDesc, insertText: newName });
                        setupVariableCompletionProvider();
                        nameInput.value = '';
                        descInput.value = '';
                    }
                });
            });
        };
    </script>
</body>
</html>