[
    {
        "id": "33283b40a0777f6a",
        "type": "tab",
        "label": "Update Metadata",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "ce9633b89106de8f",
        "type": "tab",
        "label": "graphql Server Images",
        "disabled": true,
        "info": "",
        "env": []
    },
    {
        "id": "09922ee65be58345",
        "type": "tab",
        "label": "Flow 2",
        "disabled": true,
        "info": "",
        "env": []
    },
    {
        "id": "a52209a7262ea19f",
        "type": "tab",
        "label": "graphql Server Images",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "772c07f1f620c995",
        "type": "tab",
        "label": "Bull Queue Dashboard",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "c23a997595de5280",
        "type": "tab",
        "label": "Process query apollo",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "18caed853880999b",
        "type": "tab",
        "label": "Binance",
        "disabled": true,
        "info": "",
        "env": []
    },
    {
        "id": "af13c7f5e79b8c40",
        "type": "tab",
        "label": "Binance Futures P&L",
        "disabled": true,
        "info": "",
        "env": []
    },
    {
        "id": "cdfd4aa9099e0473",
        "type": "tab",
        "label": "Flow 1",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "1e273549eda8541e",
        "type": "subflow",
        "name": "Queue Containers",
        "info": "",
        "category": "",
        "in": [
            {
                "x": 180,
                "y": 220,
                "wires": [
                    {
                        "id": "8e1fa8b70b7d4a07"
                    }
                ]
            }
        ],
        "out": [
            {
                "x": 700,
                "y": 260,
                "wires": [
                    {
                        "id": "8e1fa8b70b7d4a07",
                        "port": 1
                    }
                ]
            }
        ],
        "env": [],
        "meta": {},
        "color": "#DDAA99",
        "status": {
            "x": 620,
            "y": 180,
            "wires": [
                {
                    "id": "8e1fa8b70b7d4a07",
                    "port": 0
                }
            ]
        }
    },
    {
        "id": "5ed478d1a62e4007",
        "type": "subflow",
        "name": "Worker Containers",
        "info": "",
        "category": "",
        "in": [
            {
                "x": 120,
                "y": 200,
                "wires": [
                    {
                        "id": "df501c152ac0adb1"
                    }
                ]
            }
        ],
        "out": [
            {
                "x": 540,
                "y": 300,
                "wires": [
                    {
                        "id": "df501c152ac0adb1",
                        "port": 1
                    }
                ]
            }
        ],
        "env": [],
        "meta": {},
        "color": "#DDAA99",
        "status": {
            "x": 520,
            "y": 120,
            "wires": [
                {
                    "id": "df501c152ac0adb1",
                    "port": 0
                }
            ]
        }
    },
    {
        "id": "ee0637aa2f7fa7fe",
        "type": "subflow",
        "name": "Install Modules",
        "info": "",
        "category": "",
        "in": [
            {
                "x": 60,
                "y": 180,
                "wires": [
                    {
                        "id": "36f5ce8e4fcea9ad"
                    }
                ]
            }
        ],
        "out": [
            {
                "x": 1020,
                "y": 180,
                "wires": [
                    {
                        "id": "1318d4d262c79898",
                        "port": 0
                    },
                    {
                        "id": "1318d4d262c79898",
                        "port": 1
                    },
                    {
                        "id": "1318d4d262c79898",
                        "port": 2
                    }
                ]
            }
        ],
        "env": [],
        "meta": {},
        "color": "#DDAA99"
    },
    {
        "id": "52dd62cdb44e91b4",
        "type": "subflow",
        "name": "Graphql Client",
        "info": "",
        "category": "",
        "in": [
            {
                "x": 80,
                "y": 200,
                "wires": [
                    {
                        "id": "02292399561f8e04"
                    }
                ]
            }
        ],
        "out": [
            {
                "x": 460,
                "y": 160,
                "wires": [
                    {
                        "id": "02292399561f8e04",
                        "port": 0
                    }
                ]
            },
            {
                "x": 460,
                "y": 220,
                "wires": [
                    {
                        "id": "02292399561f8e04",
                        "port": 1
                    }
                ]
            }
        ],
        "env": [],
        "meta": {},
        "color": "#DDAA99",
        "status": {
            "x": 460,
            "y": 300,
            "wires": [
                {
                    "id": "02292399561f8e04",
                    "port": 2
                }
            ]
        }
    },
    {
        "id": "5d9d1417dea54c42",
        "type": "group",
        "z": "ee0637aa2f7fa7fe",
        "name": "Install Modules",
        "style": {
            "stroke": "#92d04f",
            "label": true,
            "color": "#3f5787",
            "fill": "#c8e7a7"
        },
        "nodes": [
            "36f5ce8e4fcea9ad",
            "295e91835df06208",
            "1318d4d262c79898",
            "4f7ce3c6799631fe"
        ],
        "x": 134,
        "y": 79,
        "w": 782,
        "h": 149.5
    },
    {
        "id": "547d2c48b4c1a6cb",
        "type": "global-config",
        "env": [
            {
                "name": "GRAPHQL_URL",
                "value": "http://localhost:4081/",
                "type": "str"
            },
            {
                "name": "REDIS_CONNECTION",
                "value": "{\"host\":\"remote1.tolife.me\",\"port\":6379,\"username\":\"default\",\"password\":\"anh08091998t\"}",
                "type": "json"
            },
            {
                "name": "REDIS_URL",
                "value": "redis://default:anh08091998t@remote1.tolife.me:6379",
                "type": "str"
            },
            {
                "name": "HASURA_URL",
                "value": "http://remote1.tolife.me:18080",
                "type": "str"
            },
            {
                "name": "POSTGRES_URL",
                "value": "postgresql://postgres:buuandbee@db1.tolife.me:5432/postgres",
                "type": "str"
            },
            {
                "name": "SERVER_SSH",
                "value": "{\"host\":\"remote1.tolife.me\",\"port\":22,\"username\":\"root\",\"password\":\"anh08091998t\"}",
                "type": "json"
            },
            {
                "name": "BINANCE_APY_KEY",
                "value": "3XB35QbcNmAfiLHlovMYp3HBcrzlNoXfORUziwFYqgFCQNMkuZke513l12g9kfq5",
                "type": "str"
            },
            {
                "name": "BINANCE_API_SECRET",
                "value": "vIA3sbOKI9sXdRVnuIny3y56fuklKTC8XYOtgddrQaz355YrattaFktRa9aDPjZN",
                "type": "str"
            }
        ],
        "modules": {}
    },
    {
        "id": "c69803de08016f9a",
        "type": "ui-base",
        "name": "My Dashboard",
        "path": "/dashboard",
        "appIcon": "",
        "includeClientData": true,
        "acceptsClientConfig": [
            "ui-notification",
            "ui-control"
        ],
        "showPathInSidebar": false,
        "headerContent": "page",
        "navigationStyle": "default",
        "titleBarStyle": "default",
        "showReconnectNotification": true,
        "notificationDisplayTime": 1,
        "showDisconnectNotification": true,
        "allowInstall": false
    },
    {
        "id": "35b8dce006027490",
        "type": "ui-theme",
        "name": "Default Theme",
        "colors": {
            "surface": "#ffffff",
            "primary": "#0094CE",
            "bgPage": "#eeeeee",
            "groupBg": "#ffffff",
            "groupOutline": "#cccccc"
        },
        "sizes": {
            "density": "default",
            "pagePadding": "12px",
            "groupGap": "12px",
            "groupBorderRadius": "4px",
            "widgetGap": "12px"
        }
    },
    {
        "id": "e2e42deb7bde4825",
        "type": "ui-page",
        "name": "Dashboard",
        "ui": "c69803de08016f9a",
        "path": "/page1",
        "icon": "home",
        "layout": "grid",
        "theme": "35b8dce006027490",
        "breakpoints": [
            {
                "name": "Default",
                "px": "0",
                "cols": "3"
            },
            {
                "name": "Tablet",
                "px": "576",
                "cols": "6"
            },
            {
                "name": "Small Desktop",
                "px": "768",
                "cols": "9"
            },
            {
                "name": "Desktop",
                "px": "1024",
                "cols": "12"
            }
        ],
        "order": 1,
        "className": "",
        "visible": "true",
        "disabled": "false"
    },
    {
        "id": "c94d49ed7a1ed8f5",
        "type": "ui-group",
        "name": "Set env",
        "page": "e2e42deb7bde4825",
        "width": 6,
        "height": 1,
        "order": 1,
        "showTitle": true,
        "className": "",
        "visible": "true",
        "disabled": "false",
        "groupType": "default"
    },
    {
        "id": "8e1fa8b70b7d4a07",
        "type": "function",
        "z": "1e273549eda8541e",
        "name": "Start Queue Container",
        "func": "// Code added here will be run once\n// whenever the node is started.\nconst { Queue, QueueEvents } = bullmq;\nconst IORedis = ioredis;\n\nconst connection = new IORedis(env.get(\"REDIS_URL\") || env.get(\"REDIS_CONNECTION\"), { maxRetriesPerRequest: null, connectionName: 'rayman',\n  connectTimeout: 1000,\n  retryStrategy: () => {\n    return false;\n  } });\nconsole.log(env.get(\"REDIS_URL\") || env.get(\"REDIS_CONNECTION\"))\n\nvar queues = {};\nvar eventQueues = {};\n\n( async () => {\n    await node.send([{\n        topic: \"status\",\n        payload: {\n            fill: \"red\",\n            shape: \"ring\",\n            text: \"Starting Queue Containers\"\n        }\n    }]);\n    await global.set(\"sendJobToQueue\", async (queueName, jobName, jobData, jobOptions = {}) => {\n        if (!queues[queueName]) {\n            queues[queueName] = await new Queue(queueName, { connection });\n            eventQueues[queueName] = await new QueueEvents(queueName, { connection });\n        };\n        var job = await queues[queueName].add(jobName, jobData, Object.assign({ removeOnComplete: 1000, removeOnFail: 5000 }, jobOptions));\n        const result = await job.waitUntilFinished(eventQueues[queueName]);\n        return result\n    });\n    await global.set(\"getQueue\", async (queueName) => {\n        if (!queues[queueName]) {\n            queues[queueName] = await new Queue(queueName, { connection });\n            eventQueues[queueName] = await new QueueEvents(queueName, { connection });\n            node.send([{\n                topic: \"status\",\n                payload: {\n                    fill: \"red\",\n                    shape: \"ring\",\n                    text: \"Starting Queue: \" + queueName\n                }\n            }]);\n        };\n        let queueJob = async (jobName, jobData, jobOptions = {}) => {\n            var job = await queues[queueName].add(jobName, jobData, jobOptions);\n            const result = await job.waitUntilFinished(eventQueues[queueName]);\n            return result\n        };\n        return queueJob\n    });\n    await node.send([{\n        topic: \"status\",\n        payload: {\n            fill: \"red\",\n            shape: \"ring\",\n            text: \"Running Queue Containers \"\n        }\n    }]);\n    node.send([null,{}])\n})()",
        "outputs": 2,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "bullmq",
                "module": "bullmq"
            },
            {
                "var": "ioredis",
                "module": "ioredis"
            }
        ],
        "x": 420,
        "y": 220,
        "wires": [
            [],
            []
        ]
    },
    {
        "id": "df501c152ac0adb1",
        "type": "function",
        "z": "5ed478d1a62e4007",
        "name": "Worker",
        "func": "const { Worker } = bullmq;\nconst IORedis = ioredis;\n\nconst connection = new IORedis(env.get(\"REDIS_URL\") || env.get(\"REDIS_CONNECTION\"), { maxRetriesPerRequest: null });\nconsole.log(\"worker\", env.get(\"REDIS_URL\") || env.get(\"REDIS_CONNECTION\"))\nvar workers = {};\n\n( async () => {\n    await node.send([{\n        topic: \"status\",\n        payload: {\n            fill: \"red\",\n            shape: \"ring\",\n            text: \"Starting Worker Containers\"\n        }\n    }]);\n    await global.set(\"setWorker\", async (queueName, workerRun, options) => {\n        if (workers[queueName]) {\n            await workers[queueName].pause(true)\n        };\n        workers[queueName] = await new Worker(queueName, async (job) => {\n            workerRun(job)\n        }, { options, connection })\n    })\n    await node.send([{\n        topic: \"status\",\n        payload: {\n            fill: \"red\",\n            shape: \"ring\",\n            text: \"Running Worker Containers\"\n        }\n    }]);\n    await node.send([null, {}]);\n    // await flow.get(\"emitter\").emit(\"initWebApp\", {})\n})()",
        "outputs": 2,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "// Code added here will be run when the\n// node is being stopped or re-deployed.\ncontext.get(\"Worker\").pause(true);",
        "libs": [
            {
                "var": "bullmq",
                "module": "bullmq"
            },
            {
                "var": "ioredis",
                "module": "ioredis"
            }
        ],
        "x": 280,
        "y": 200,
        "wires": [
            [],
            []
        ]
    },
    {
        "id": "36f5ce8e4fcea9ad",
        "type": "function",
        "z": "ee0637aa2f7fa7fe",
        "g": "5d9d1417dea54c42",
        "name": "Kiểm tra các thư viện cần thiết",
        "func": "// --- CHỈNH SỬA DANH SÁCH NÀY ---\nconst requiredPackages = msg.payload.modules || [];\n// -------------------------------------\n\nconst packagesToInstall = [];\n\nnode.log(`Bắt đầu kiểm tra ${requiredPackages.length} thư viện...`);\n\nfor (const pkg of requiredPackages) {\n    try {\n        // Đây là cách chuẩn để kiểm tra module tồn tại mà không cần load nó\n        require.resolve(pkg);\n        node.log(`- [OK] ${pkg} đã được cài đặt.`);\n    } catch (e) {\n        // Nếu có lỗi, nghĩa là module chưa được cài\n        node.log(`- [Thiếu] ${pkg} chưa được cài đặt.`);\n        packagesToInstall.push(pkg);\n    }\n}\n\n// Nếu có thư viện cần cài, gửi danh sách đi\nif (packagesToInstall.length > 0) {\n    msg.payload = packagesToInstall.join(' '); // npm install có thể nhận nhiều package cách nhau bằng dấu cách\n    return msg;\n}\n\n// Nếu không có gì để cài, dừng luồng\nnode.log(\"Tất cả thư viện cần thiết đã có sẵn.\");\nnode.status({fill:\"green\", shape:\"dot\", text:\"All packages OK\"});\nreturn null;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 290,
        "y": 180,
        "wires": [
            [
                "295e91835df06208"
            ]
        ]
    },
    {
        "id": "295e91835df06208",
        "type": "switch",
        "z": "ee0637aa2f7fa7fe",
        "g": "5d9d1417dea54c42",
        "name": "Có cần cài đặt không?",
        "property": "payload",
        "propertyType": "msg",
        "rules": [
            {
                "t": "nempty"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 1,
        "x": 550,
        "y": 180,
        "wires": [
            [
                "1318d4d262c79898",
                "4f7ce3c6799631fe"
            ]
        ]
    },
    {
        "id": "1318d4d262c79898",
        "type": "exec",
        "z": "ee0637aa2f7fa7fe",
        "g": "5d9d1417dea54c42",
        "command": "npm install",
        "addpay": "payload",
        "append": "",
        "useSpawn": "false",
        "timer": "",
        "winHide": false,
        "oldrc": false,
        "name": "Chạy npm install",
        "x": 800,
        "y": 180,
        "wires": [
            [],
            [],
            []
        ]
    },
    {
        "id": "4f7ce3c6799631fe",
        "type": "debug",
        "z": "ee0637aa2f7fa7fe",
        "g": "5d9d1417dea54c42",
        "name": "Sẽ cài đặt:",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": true,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "payload",
        "statusType": "auto",
        "x": 780,
        "y": 120,
        "wires": []
    },
    {
        "id": "02292399561f8e04",
        "type": "function",
        "z": "52dd62cdb44e91b4",
        "name": "function 2",
        "func": "const { query, variables, operationName, schema } = msg.payload.graphQlData;\n\nnode.send([null, null, {\n    payload: { fill: \"green\", shape: \"ring\", text: \"fetching\" }\n}])\n\nconst { errors, data } = await axios({\n        url: `${env.get(\"GRAPHQL_URL\")}` + schema,\n        method: 'post',\n        headers: {\n            'Content-Type': 'application/json'\n        },\n        data: JSON.stringify({\n            query,\n            variables\n    })\n}).catch(err => {\n    console.log(\"err requets graphql\", err)\n});\n\nconsole.log(errors, data)    \n\nmsg.payload[operationName] = data;\nlet outputs = [null, null, { topic: \"status\", payload: { fill:\"red\",shape:\"ring\",text: \"done\" }}]\nif (errors) {\n    outputs[0] = msg;\n    outputs[2].payload.text = data;\n} else {\n    outputs[1] = msg;\n    outputs[2].payload = { fill: \"green\", shape: \"ring\", text: \"done\" };\n}\nnode.send(outputs)\n\nreturn null;",
        "outputs": 3,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "axios",
                "module": "axios"
            }
        ],
        "x": 280,
        "y": 200,
        "wires": [
            [],
            [],
            []
        ],
        "outputLabels": [
            "errors",
            "data",
            "status"
        ]
    },
    {
        "id": "865ead7de6e66ad1",
        "type": "function",
        "z": "33283b40a0777f6a",
        "d": true,
        "name": "function 1",
        "func": "const {\n  S3Client,\n  ListBucketsCommand,\n  ListObjectsV2Command,\n  GetObjectCommand,\n  PutObjectCommand,\n}  = awsSdkClientS3;\n\nconst S3 = new S3Client({\n  region: \"auto\",\n  endpoint: `https://${\"cabeebbd339be94fb532e563a50ffd18\"}.r2.cloudflarestorage.com`,\n  credentials: {\n    accessKeyId: \"048a48a207a5cb4a83679a232df9114a\",\n    secretAccessKey: \"a8d97652428fd8c8016c72a3933125aacf56537531786d0cd9517a59b21c4651\",\n  },\n});\n\nasync function listBuckets() {\n  const command = new ListBucketsCommand({});\n  const response = await S3.send(command);\n  return response.Buckets;\n}\n\nasync function listObjects(bucketName) {\n  const command = new ListObjectsV2Command({ Bucket: bucketName });\n  const response = await S3.send(command);\n  return response.Contents;\n}\n\nasync function getObject(bucketName, objectKey) {\n  const command = new GetObjectCommand({ Bucket: bucketName, Key: objectKey });\n  const response = await S3.send(command);\n  return response.Body;\n}\n\nasync function putObject(bucketName, objectKey, body) {\n  const command = new PutObjectCommand({ Bucket: bucketName, Key: objectKey, Body: body });\n  const response = await S3.send(command);\n  return response;\n}\n\nconsole.log(await listBuckets())\nconsole.log(await listBuckets())\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "awsSdkClientS3",
                "module": "@aws-sdk/client-s3"
            }
        ],
        "x": 660,
        "y": 940,
        "wires": [
            []
        ]
    },
    {
        "id": "3fd068beaa112397",
        "type": "inject",
        "z": "33283b40a0777f6a",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 420,
        "y": 940,
        "wires": [
            [
                "865ead7de6e66ad1",
                "a4cc809efa62c72d"
            ]
        ]
    },
    {
        "id": "a4cc809efa62c72d",
        "type": "function",
        "z": "33283b40a0777f6a",
        "name": "function 2",
        "func": "console.log(fsPromises.mkdir(\"./tesst\", { recursive: true}))\n\nvar require = global.get('require');\nconst { Build_S3 } = require('/Users/hanwister/Library/CloudStorage/OneDrive-Personal/Developer/red/aws/s3_client.js');\n\nconst s3 = new Build_S3();\nawait s3.connect({\n  endpoint: `https://${\"cabeebbd339be94fb532e563a50ffd18\"}.r2.cloudflarestorage.com`,\n  accessKeyId: \"048a48a207a5cb4a83679a232df9114a\",\n  secretAccessKey: \"a8d97652428fd8c8016c72a3933125aacf56537531786d0cd9517a59b21c4651\",\n});\n\nconsole.log( await s3.listBuckets() );\n\n// console.log( await s3.getObject(\"dudu-bucket\", \"flowforge-installer.zip\"))\nconsole.log( await s3.writeObjectToFile(\"dudu-bucket\", \"flowforge-installer.zip\", \"./bucket\"))",
        "outputs": 1,
        "timeout": 0,
        "noerr": 1,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "awsSdkClientS3",
                "module": "@aws-sdk/client-s3"
            },
            {
                "var": "process",
                "module": "process"
            },
            {
                "var": "childProcess",
                "module": "child_process"
            },
            {
                "var": "fsPromises",
                "module": "fs/promises"
            }
        ],
        "x": 640,
        "y": 1080,
        "wires": [
            []
        ]
    },
    {
        "id": "e989576b8205a1d3",
        "type": "inject",
        "z": "33283b40a0777f6a",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 120,
        "y": 400,
        "wires": [
            [
                "22491d7032df4281",
                "bf835cc3056b07fb",
                "7d78ef75e63aac27",
                "defef4736b50d816",
                "a14adc74ed840788"
            ]
        ]
    },
    {
        "id": "22491d7032df4281",
        "type": "function",
        "z": "33283b40a0777f6a",
        "name": "fetch Tables",
        "func": "const fetchTables = async () => {\n\n    return await new Promise ( async (resolve, reject)=> {\n        node.send([null, null, {\n            payload: { fill: \"green\", shape: \"ring\", text: \"fetching\" }\n        }])\n        const { errors, data } = await new Promise( (resolve, reject) => {\n            axios({\n                url: `${env.get(\"GRAPHQL_URL\")}` + \"private\",\n                method: 'post',\n                headers: {\n                    'Content-Type': 'application/json'\n                },\n                data: JSON.stringify({\n                    query: `\n                        query List_table($where: ModeltableWhereInput) {\n                                list_table(where: $where) { id createdAt updatedAt name schema getter setter columns:list_column {\n                                    id, type, required, is_many, name, relations:list_relation {\n                                        field, reference\n                                }}}}`,\n                    variables: {\n                        \"where\": {\n                            \"schema\": {\n                                // \"_in\": [\"dev\", \"app\", \"auth\", \"style\", \"cloud\"]\n                                // \"_in\": [\"dev\"]\n                            }\n                        }\n                    }\n                })\n            })\n            .then(res => {\n                console.log(res)\n                resolve(res)\n            })\n            .catch(err => {\n                resolve(({\n                    errors: [{\n                        message: err.message\n                    }]\n                }))\n            });\n\n        })\n        \n        node.send([null, null, {\n            payload: { fill: \"green\", shape: \"ring\", text: \"done\" }\n        }])\n            resolve({\n                errors, data\n            })\n        \n        })   \n         \n}\n\nnode.send([null, null, {\n    payload: { fill: \"green\", shape: \"ring\", text: \"fetching\" }\n}])\n\nflow.set(\"fetchTables\", fetchTables);\n\nreturn { payload: {}};",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "axios",
                "module": "axios"
            }
        ],
        "x": 350,
        "y": 380,
        "wires": [
            [
                "b9e6b63d4f07ec2d"
            ]
        ]
    },
    {
        "id": "bf835cc3056b07fb",
        "type": "function",
        "z": "33283b40a0777f6a",
        "name": "write Prisma",
        "func": "const { writeFile, mkdir } = fsPromises;\nconst __dirname = \".\";\n\nasync function createPrismaFile(tableMap, outdir = \"./prisma\") {\n\n}\n\n\n\nclass Build_Prisma {\n    constructor(configs) {\n        this.typeDefType = new Map([\n            [\"0\", \"ID\"],\n            [\"1\", \"Int\"],\n            [\"2\", \"Float\"],\n            [\"3\", \"String\"],\n            [\"4\", \"Boolean\"],\n            [\"5\", \"DateTime\"],\n            [\"6\", \"Json\"],\n        ]);\n\n        this.filterPrismaToHasura = new Map([\n            [\"neq\", [\"_neq\"]],\n            [\"eq\", [\"_eq\"]],\n            [\"equals\", [\"_eq\"]],\n            [\"lte\", [\"[_lte\"]],\n            [\"lt\", [\"_lt\"]],\n            [\"gte\", [\"_gte\"]],\n            [\"gt\", [\"_gt\"]],\n            [\"in\", [\"_in\"]],\n            [\"notIn\", [\"_nin\"]],\n            [\"like\", [\"_like\"]],\n            [\"iLike\", [\"_ilike\"]],\n            [\"regex\", [\"_regex\"]],\n            [\"iRegex\", [\"_iregex\"]],\n            [\"and\", [\"_and\"]],\n            [\"or\", [\"_or\"]],\n            [\"not\", [\"_not\"]],\n            [\"distinctOn\", [\"distinct_on\"]],\n            [\"orderBy\", [\"order_by\"]],\n            [\"hasKey\", [\"_has_key\"]],\n            [\"cast\", [\"_cast\"]],\n            [\"String\", [\"String\"]],\n            [\"path\", [\"path\"]],\n        ]);\n\n        this.filterPrismaToHasuraInWhere = new Map([\n            [\"neq\", [\"_neq\"]],\n            [\"eq\", [\"_eq\"]],\n            [\"equals\", [\"_eq\"]],\n            [\"lte\", [\"[_lte\"]],\n            [\"lt\", [\"_lt\"]],\n            [\"gte\", [\"_gte\"]],\n            [\"gt\", [\"_gt\"]],\n            [\"in\", [\"_in\"]],\n            [\"notIn\", [\"_nin\"]],\n            [\"like\", [\"_like\"]],\n            [\"iLike\", [\"_ilike\"]],\n            [\"regex\", [\"_regex\"]],\n            [\"iRegex\", [\"_iregex\"]],\n            [\"hasKey\", [\"_has_key\"]],\n            [\"isNull\", [\"_is_null\"]],\n        ]);\n\n        this.configs = Object.assign({}, configs)\n        this.clientId = this.configs.path || \"default\";\n        this.schemaFile = `${__dirname}/prisma${this.configs.path}.prisma`;\n    };\n\n    initPrismaSchema = () => `\n  generator client {\n      provider = \"prisma-client-js\"\n      previewFeatures = [\"multiSchema\"]\n      output = \"${this.clientFolder}\"\n      binaryTargets = [\"native\", \"linux-musl-openssl-3.0.x\"]\n  } \n  datasource db {\n      provider = \"${\"postgresql\"}\"\n      url      = \"${this.configs.db_url}\"\n      schemas  = ${JSON.stringify([...new Set([...this.tableMap].map(([id, { schema }]) => schema))])}\n  }\n      \n  `;\n\n    async generatePrismaSchema(tableMap = null) {\n        this.tableMap = (tableMap || this.tableMap) || new Map();\n        let schemaFull = [\n            this.initPrismaSchema(),\n            ...[...this.tableMap].map(\n                ([table_id, { columns, schema }]) => `\nmodel ${table_id} {\n\\tid       String  @id @default(dbgenerated(\"gen_random_uuid()\"))\n\\tcreatedAt DateTime @default(now())\n\\tupdatedAt DateTime? @updatedAt\n\\tdeletedAt DateTime?\n\\t${columns.filter(({ id, type, is_many, required, relations }) => this.typeDefType.has(type) || (this.tableMap.has(type) && false)).map(({ id, type, is_many, required, relations }) => `${id}\\t${this.typeDefType.get(type) || type}${is_many ? \"[]\" : (required && !table_id.endsWith(\"history\")) && false ? \"\" : \"?\"}${relations && relations.length > 0 && !is_many ? ` @relation( fields: [${relations.map(({ field }) => field).join(\", \")}], references: [${relations.map(({ reference }) => reference).join(\", \")}])` : \"\"}`).join(\"\\n\\t\")}\n\\t@@map(\"${table_id}\")\n\\t@@schema(\"${schema}\")\n}\n`,\n            ),\n        ].join(\"\\n\");\n\n        return schemaFull;\n    }\n\n    async generatePrismaClient(tableMap) {\n        this.clientFolder = `${__dirname}/prisma/${this.clientId}`;\n        this.schemaFile = `${__dirname}/prisma/${this.clientId}.prisma`;\n        await mkdir(`${__dirname}/prisma`, { recursive: true })\n        console.log(\"Schema prisma creating ...\");\n        await writeFile(\"./prisma/tesst.text\", \"test\")\n        await writeFile(this.schemaFile, await this.generatePrismaSchema(tableMap))\n        console.log(\"Schema prisma done!\");\n        // await this.bash(\"Format\", `npx prisma format --schema=\"${this.schemaFile}\"`);\n        // await this.bash(\"Generate\", `npx prisma generate --schema=\"${this.schemaFile}\"`);\n    }\n\n    async connect() {\n        const { PrismaClient } = await import(`${this.clientFolder}/index.js`);\n        this.client = new PrismaClient();\n        await this.client.$connect();\n        return this.client;\n    }\n\n    async push() {\n        await this.generatePrismaClient();\n        // await this.bash(\"Db Push\", `npx prisma db push --schema=\"${this.schemaFile}\"`);\n        // await this.bash(\"Db Push\", `npx prisma db push --schema=${this.schemaFile} --accept-data-loss`);\n        // await this.bash(\"Db Push\", `npx prisma migrate deploy --schema=\"${this.schemaFile}\"`);\n        // await this.pushHasura(process.env.HASURA_URL);\n        this.generated = true;\n    }\n\n    async start() {\n        await this.connectHasura(process.env.HASURA_URL);\n        if (!this.generated) {\n            await this.generatePrismaClient();\n        }\n        await this.connect();\n        // await this.client.$executeRaw(``)\n    }\n\n    async exit() {\n        this.client.$disconnect();\n        console.log('Close ', this.version)\n        this.wsApp && this.wsApp.close()\n    }\n}\n\nflow.set(\"Build_Prisma\", Build_Prisma)\n\nreturn { payload: {}};",
        "outputs": 1,
        "timeout": 0,
        "noerr": 11,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "fsPromises",
                "module": "fs/promises"
            }
        ],
        "x": 350,
        "y": 440,
        "wires": [
            [
                "b9e6b63d4f07ec2d"
            ]
        ]
    },
    {
        "id": "b9e6b63d4f07ec2d",
        "type": "join",
        "z": "33283b40a0777f6a",
        "name": "",
        "mode": "custom",
        "build": "array",
        "property": "payload",
        "propertyType": "msg",
        "key": "topic",
        "joiner": "\\n",
        "joinerType": "str",
        "useparts": false,
        "accumulate": false,
        "timeout": "",
        "count": "5",
        "reduceRight": false,
        "reduceExp": "",
        "reduceInit": "",
        "reduceInitType": "num",
        "reduceFixup": "",
        "x": 650,
        "y": 420,
        "wires": [
            [
                "4c09207cc30af972"
            ]
        ]
    },
    {
        "id": "7d78ef75e63aac27",
        "type": "function",
        "z": "33283b40a0777f6a",
        "name": "writte Hasura",
        "func": "const { writeFile, mkdir, readFile } = fsPromises;\nconst __dirname = \".\";\n\nclass Build_Hasura {\n    constructor(configs) {\n        this.configs = Object.assign({}, configs)\n        this.clientId = this.configs.path || \"default\";\n        this.schemaFile = `${__dirname}/hasura/${this.configs.path}.json`;\n    };\n\n    initHasuraSchema = (tables) => ({\n        \"resource_version\": 1148,\n        \"metadata\": {\n            \"version\": 3,\n            \"sources\": [\n                {\n                    \"name\": \"dudu-postgres\",\n                    \"kind\": \"postgres\",\n                    tables,\n                    \"configuration\": {\n                        \"connection_info\": {\n                            \"database_url\": this.configs.db_url,\n                            \"isolation_level\": \"read-committed\",\n                            \"pool_settings\": {\n                                \"connection_lifetime\": 600,\n                                \"idle_timeout\": 180,\n                                \"max_connections\": 50,\n                                \"retries\": 1\n                            },\n                            \"use_prepared_statements\": false\n                        }\n                    }\n                }\n            ]\n        }\n    });\n\n    async generateHasuraSchema(tableMap = null) {\n        this.tableMap = (tableMap || this.tableMap) || new Map();\n        let tables = [ ... tableMap].map( ([tableId, { schema, columns}]) => ({\n            table: {\n                name: tableId,\n                schema\n            },\n            \"array_relationships\": columns.filter( ({ relations }) => ( relations || []).length ).map( ({ id: columnId, relations, type: remoteTable, schema: remoteSchema }) => ({\n                name: 'list_' + remoteTable,\n                using: {\n                    \"manual_configuration\": {\n                        \"column_mapping\": Object.fromEntries( relations.map( ({ field, reference }) => ([ field, reference ]))),\n                        \"insertion_order\": null,\n                        \"remote_table\": {\n                            \"name\": remoteTable,\n                            \"schema\": remoteSchema || schema\n                        }\n                    }\n                }\n            }))  \n        }))\n        return JSON.stringify(await this.initHasuraSchema(tables), null, \"\\t\")\n    }\n\n    async generateHasuraClient(tableMap) {\n        this.clientFolder = `${__dirname}/hasura/${this.clientId}`;\n        this.schemaFile = `${__dirname}/hasura/${this.clientId}.json`;\n        await mkdir(`${__dirname}/hasura`, { recursive: true })\n        console.log(\"Schema hasura creating ...\");\n\n        await writeFile(this.schemaFile, await this.generateHasuraSchema(tableMap))\n        console.log(\"Schema hasura done!\");\n        // await this.bash(\"Format\", `npx Hasura format --schema=\"${this.schemaFile}\"`);\n        // await this.bash(\"Generate\", `npx Hasura generate --schema=\"${this.schemaFile}\"`);\n    }\n\n    async connect() {\n        const { HasuraClient } = await import(`${this.clientFolder}/index.js`);\n        this.client = new HasuraClient();\n        await this.client.$connect();\n        return this.client;\n    }\n\n    async push() {\n        await this.generateHasuraClient();\n        // await this.bash(\"Db Push\", `npx Hasura db push --schema=\"${this.schemaFile}\"`);\n        // await this.bash(\"Db Push\", `npx Hasura db push --schema=${this.schemaFile} --accept-data-loss`);\n        // await this.bash(\"Db Push\", `npx Hasura migrate deploy --schema=\"${this.schemaFile}\"`);\n        // await this.pushHasura(process.env.HASURA_URL);\n        this.generated = true;\n    }\n\n    async start() {\n        await this.connectHasura(process.env.HASURA_URL);\n        if (!this.generated) {\n            await this.generateHasuraClient();\n        }\n        await this.connect();\n        // await this.client.$executeRaw(``)\n    }\n\n    async sendToServer(url, options = {}) {\n        options = Object.assign( {}, options);\n        if (!options.data) {\n            options.data = JSON.parse(await readFile(`${__dirname}/hasura/${this.clientId}.json`, { encoding: 'utf8' }))\n        };\n        \n        let headers = {\n            \"x-hasura-admin-secret\": \"anh08091998t@HASURA\",\n            \"content-type\": \"application/json\"\n        };\n\n        let pre_resource = ( await axios.post(`${url}/v1/metadata`, {\n            \"type\": \"export_metadata\",\n            \"version\": 2,\n            \"args\": {}\n        }, { headers }));\n        console.log(pre_resource.data[\"resource_version\"])\n        options.data[\"resource_version\"] = pre_resource.data[\"resource_version\"]\n        console.log( (await axios.post(`${url}/v1/metadata`, {\n                resource_version: options.data[\"resource_version\"],\n                source: \"\",\n                type: \"bulk\",\n                args: [\n                    { type: 'replace_metadata',\n                        args: options.data\n                    }\n                ]\n            }, {\n            headers\n        } )).data)\n    }\n\n    async exit() {\n        this.client.$disconnect();\n        console.log('Close ', this.version)\n        this.wsApp && this.wsApp.close()\n    }\n}\n\nflow.set(\"Build_Hasura\", Build_Hasura)\n\nreturn { payload: {} };",
        "outputs": 1,
        "timeout": 0,
        "noerr": 7,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "fsPromises",
                "module": "fs/promises"
            },
            {
                "var": "axios",
                "module": "axios"
            }
        ],
        "x": 350,
        "y": 500,
        "wires": [
            [
                "b9e6b63d4f07ec2d"
            ]
        ]
    },
    {
        "id": "4c09207cc30af972",
        "type": "function",
        "z": "33283b40a0777f6a",
        "name": "Main",
        "func": "const { createId } = paralleldriveCuid2;\nconst { readFile } = fsPromises;\nconst bash = flow.get(\"bash\");\nconst ssh = flow.get(\"ssh\");\n\nlet privateTables = JSON.parse( await readFile(\"./configs/private.json\", { encoding: \"utf8\" }));\n\nlet protectedTables = JSON.parse( await readFile(\"./configs/protected.json\", { encoding: \"utf8\" }));\n\nconst updateMetadata = async () => {\n    const { errors, data } = await flow.get(\"fetchTables\")();\n\n    let tableMap = new Map([ ...privateTables, ...protectedTables, ... errors ? [] : data.data.list_table ].map( (table) => [ table.id, table ]))\n\n    const Build_Prisma = await flow.get(\"Build_Prisma\");\n    const Prisma = new Build_Prisma({\n        db_url: env.get(\"POSTGRES_URL\")\n    })\n    Prisma.generatePrismaClient(tableMap)\n\n    await bash(\"Format Prisma File\", `npx prisma format --schema=\"./prisma/default.prisma\"`);\n    // await bash(\"Generate Prisma File\", `npx prisma generate --schema=\"./prisma/default.prisma\"`);\n\n    let ssh_client = await ssh(env.get(\"SERVER_SSH\"));\n    await ( async () => {\n        let { error, payload } = await ssh_client.execCommand(\"sudo bash -H -lc 'node -v'\", { cwd: \"/root\"})\n        if ((error && error.endsWith(\"node: command not found\\n\")) || (payload && !payload.startsWith(\"v22\")) ) {\n            // await ssh_client.execCommand(\"curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.40.3/install.sh | bash & source ~/.bashrc & nvm install 22 -y\")\n            //   await ssh_client.execCommand(\"nvm install 22\")\n            await ssh_client.execCommand(\"sudo rm -r /etc/apt/sources.list.d/nodesource.list*\", { cwd: \"/root\"})\n            await ssh_client.execCommand(\"apt-cache policy nodejs\", { cwd: \"/root\"})\n            await ssh_client.execCommand(\"sudo apt-get autoremove\", { cwd: \"/root\"})\n            await ssh_client.execCommand(\"sudo snap remove node\", { cwd: \"/root\"})\n            await ssh_client.execCommand(\"curl -fsSL https://deb.nodesource.com/setup_22.x | sudo -E bash -\", { cwd: \"/root\"})\n            // await ssh_client.execCommand(\"sudo apt-get update\", { cwd: \"/root\"})\n            await ssh_client.execCommand(\"sudo apt-get install -y nodejs\", { cwd: \"/root\" });\n            await ssh_client.execCommand(\"sudo bash -H -lc 'node -v'\", { cwd: \"/root\"})\n        };\n    })()\n\n    await ( async () => {\n        let { error, payload } = await ssh_client.execCommand(\"npx -v\")\n        if ( error && error.endsWith(\"npx: command not found\\n\")) {\n            await ssh_client.execCommand(\"sudo npm i npx -g -y\")\n        };\n    })()\n\n    await ( async () => {\n        let { error, payload } = await ssh_client.execCommand(\"npx prisma -v\")\n        if ( error && error.endsWith(\"npx: command not found\\n\")) {\n            await ssh_client.execCommand(\"sudo npm i npx -g -y\")\n        };\n    })()\n\n    await ( async () => {\n        await ssh_client.putFile(\"./prisma/default.prisma\", \"./prisma/default.prisma\");\n        await ssh_client.execCommand(\"sudo npx prisma db push --schema='./prisma/default.prisma'\")\n    })()\n\n    const Build_Hasura = await flow.get(\"Build_Hasura\");\n    const Hasura = new Build_Hasura({\n        db_url: env.get(\"POSTGRES_URL\")\n    })\n    await Hasura.generateHasuraClient(tableMap)\n    await Hasura.sendToServer(env.get(\"HASURA_URL\"))\n    if (errors) {\n        await updateMetadata()\n    }\n}\n\nawait updateMetadata()\n\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "fsPromises",
                "module": "fs/promises"
            },
            {
                "var": "childProcess",
                "module": "child_process"
            },
            {
                "var": "paralleldriveCuid2",
                "module": "@paralleldrive/cuid2"
            }
        ],
        "x": 550,
        "y": 580,
        "wires": [
            []
        ]
    },
    {
        "id": "7ccb49c1f4141ef7",
        "type": "inject",
        "z": "33283b40a0777f6a",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 140,
        "y": 640,
        "wires": [
            [
                "4c09207cc30af972"
            ]
        ]
    },
    {
        "id": "defef4736b50d816",
        "type": "function",
        "z": "33283b40a0777f6a",
        "name": "set Bash",
        "func": "const { exec } = childProcess;\n\n const bash = async (name, bash_scripts) => {\n    console.log(`${name} started!`);\n    return await new Promise((resolve, reject) => {\n        exec(bash_scripts, (err, stdout, stderr) => {\n            if (err) {\n                console.error(err.message);\n            }\n            if (stdout) {\n                console.error(stdout);\n            }\n            if (stderr) {\n                console.error(stderr);\n            }\n            console.log(`${name} finished!`);\n            resolve(\"Ok\");\n        });\n    });\n};\n\nflow.set(\"bash\", bash);\n\nreturn { payload: {}};",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "childProcess",
                "module": "child_process"
            }
        ],
        "x": 340,
        "y": 240,
        "wires": [
            [
                "b9e6b63d4f07ec2d"
            ]
        ]
    },
    {
        "id": "a14adc74ed840788",
        "type": "function",
        "z": "33283b40a0777f6a",
        "name": "create SSH Client",
        "func": "const { NodeSSH } = nodeSsh;\n\nvar sshContainers = {};\n\n\nclass SSH_Client {\n    constructor() {\n        this.ssh = new NodeSSH();\n    }\n\n    async connect(params) {\n        params = Object.assign({\n            tryKeyboard: true,\n            onKeyboardInteractive(name, instructions, instructionsLang, prompts, finish) {\n            if (prompts.length > 0 && prompts[0].prompt.toLowerCase().includes('password')) {\n                finish([params.password])\n            }\n            }\n        }, params)\n        console.log(params)\n        await this.ssh.connect(params);\n        return this\n    }\n\n    async execCommand(command, options = {}) {\n        return new Promise( async (resolve, reject) => {\n            let res = { error: '', payload: '' }\n            options = {\n                ...{\n                    stream: \"both\",\n                    onStdout(chunk) {\n                        console.log(\"out\", chunk.toString(\"utf8\"));\n                        res.payload += chunk.toString(\"utf8\")\n                    },\n                    onStderr(chunk) {\n                        console.log( \"error\", chunk.toString(\"utf8\"));\n                        res.error += chunk.toString(\"utf8\")\n                    },\n                },\n                ...options,\n            };\n            await this.ssh.execCommand(command, options);\n            resolve(res)\n        })\n    }\n\n    async exec(\n        command,\n        parameters,\n        options= { stream: \"both\" },\n    ) {\n        options = {\n            ...{\n                // stream: \"both\",\n                onStdout(chunk) {\n                    console.log(chunk.toString(\"utf8\"));\n                },\n                onStderr(chunk) {\n                    console.log(chunk.toString(\"utf8\"));\n                },\n            },\n            ...options,\n        };\n        return await this.ssh.exec(command, parameters, options);\n    }\n\n    async putFile(localFile, remoteFile, options = {}) {\n        const failed = [];\n        const successful = [];\n        let status = await this.ssh.putFiles([{\n            local: localFile,\n            remote: remoteFile\n        }]);\n        return { status, failed, successful }\n    }\n\n    async putDirectory(localFolder, remoteFolder, options = {}) {\n        const failed = [];\n        const successful = [];\n        options = {\n            ...{\n                recursive: true,\n                concurrency: 10,\n                // ^ WARNING: Not all servers support high concurrency\n                // try a bunch of values and see what works on your server\n                validate: function (itemPath) {\n                    const baseName = basename(itemPath);\n                    return (\n                        // baseName.substr(0, 1) !== \".\" && // do not allow dot files\n                        baseName !== \"node_modules\"\n                    ); // do not allow node_modules\n                },\n                tick: function (localPath, remotePath, error) {\n                    if (error) {\n                        failed.push(localPath);\n                    } else {\n                        successful.push(localPath);\n                    }\n                },\n            },\n        };\n        let status = await this.ssh.putDirectory(localFolder, remoteFolder, options);\n        return { status, failed, successful }\n    }\n\n    async exit() {\n        this.ssh.dispose()\n    }\n}\n\nconst ssh = async (param_connect, name = null) => {\n    if (!name) {\n        let ssh_client = new SSH_Client();\n        await ssh_client.connect(param_connect);\n        return ssh_client\n    }\n    if (!sshContainers.hasOwnProperty(name)) {\n        let ssh_client = new SSH_Client();\n        await ssh_client.connect(param_connect);\n        sshContainers[name] = ssh_client\n    }\n    return sshContainers[name]\n}\n\nflow.set(\"ssh\", ssh);\nreturn { payload: {} };",
        "outputs": 1,
        "timeout": 0,
        "noerr": 29,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "nodeSsh",
                "module": "node-ssh"
            }
        ],
        "x": 350,
        "y": 320,
        "wires": [
            [
                "b9e6b63d4f07ec2d"
            ]
        ]
    },
    {
        "id": "5ad5f579311f38d9",
        "type": "function",
        "z": "ce9633b89106de8f",
        "name": "Start Emitter",
        "func": "( async () => {\n    await node.status({\n        fill: \"red\",\n        shape: \"ring\",\n        text: \"Starting\"\n    })\n    var emitter = new events.EventEmitter();\n    emitter.setMaxListeners(0);\n    await flow.set(\"emitter\", emitter);\n    await node.status({\n        fill: \"red\",\n        shape: \"ring\",\n        text: \"Running\"\n    });\n    node.send({})\n})()\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "events",
                "module": "events"
            }
        ],
        "x": 370,
        "y": 200,
        "wires": [
            [
                "291ce05e87428530"
            ]
        ],
        "icon": "node-red/arrow-in.svg"
    },
    {
        "id": "9d999614cfc1609a",
        "type": "function",
        "z": "ce9633b89106de8f",
        "name": "Start Queue Container",
        "func": "// Code added here will be run once\n// whenever the node is started.\nconst { Queue, QueueEvents } = bullmq;\nconst IORedis = ioredis;\n\nconst connection = new IORedis(env.get(\"REDIS_URL\") || env.get(\"REDIS_CONNECTION\"), { maxRetriesPerRequest: null });\n\nvar queues = {};\nvar eventQueues = {};\n\n( async () => {\n    await node.status({\n        fill: \"red\",\n        shape: \"ring\",\n        text: \"Starting\"\n    })\n    await flow.set(\"sendJobToQueue\", async (queueName, jobName, jobData, jobOptions = {}) => {\n        if (!queues[queueName]) {\n            queues[queueName] = await new Queue(queueName, { connection });\n            eventQueues[queueName] = await new QueueEvents(queueName, { connection });\n        };\n        var job = await queues[queueName].add(jobName, jobData, Object.assign({ removeOnComplete: 1000, removeOnFail: 5000 }, jobOptions));\n        const result = await job.waitUntilFinished(eventQueues[queueName]);\n        return result\n    });\n    await flow.set(\"getQueue\", async (queueName) => {\n        if (!queues[queueName]) {\n            queues[queueName] = await new Queue(queueName, { connection });\n            eventQueues[queueName] = await new QueueEvents(queueName, { connection });\n        };\n        let queueJob = async (jobName, jobData, jobOptions = {}) => {\n            var job = await queues[queueName].add(jobName, jobData, jobOptions);\n            const result = await job.waitUntilFinished(eventQueues[queueName]);\n            return result\n        };\n        return queueJob\n    });\n    await node.status({\n        fill: \"red\",\n        shape: \"ring\",\n        text: \"Running\"\n    });\n    node.send({})\n})()",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "bullmq",
                "module": "bullmq"
            },
            {
                "var": "ioredis",
                "module": "ioredis"
            }
        ],
        "x": 1020,
        "y": 40,
        "wires": [
            []
        ]
    },
    {
        "id": "df80cd313dda5a6f",
        "type": "function",
        "z": "ce9633b89106de8f",
        "name": "Config Worker Container",
        "func": "const { Worker } = bullmq;\nconst IORedis = ioredis;\n\nconst connection = new IORedis(env.get(\"REDIS_URL\") || env.get(\"REDIS_CONNECTION\"), { maxRetriesPerRequest: null });\n\nvar workers = {};\n\n( async () => {\n    await node.status({\n        fill: \"red\",\n        shape: \"ring\",\n        text: \"Starting\"\n    })\n    await flow.set(\"setWorker\", async (queueName, workerRun, options) => {\n        if (workers[queueName]) {\n            await workers[queueName].pause(true)\n        };\n        workers[queueName] = await new Worker(queueName, async (job) => {\n            workerRun(job)\n        }, { options, connection })\n    })\n    await node.status({\n        fill: \"red\",\n        shape: \"ring\",\n        text: \"Running\"\n    });\n    node.send({});\n    await flow.get(\"emitter\").emit(\"initWebApp\", {})\n})()",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "bullmq",
                "module": "bullmq"
            },
            {
                "var": "ioredis",
                "module": "ioredis"
            }
        ],
        "x": 1010,
        "y": 100,
        "wires": [
            []
        ]
    },
    {
        "id": "1a27e765d2407d77",
        "type": "function",
        "z": "ce9633b89106de8f",
        "name": "Start WebSerer",
        "func": "\nawait node.status({\n    fill: \"red\",\n    shape: \"ring\",\n    text: \"Starting at: \" + new Date()\n})\nawait context.get(\"init\")()\nawait node.status({\n    fill: \"red\",\n    shape: \"ring\",\n    text: \"Running at: \" + new Date()\n});\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "const { createServer, request } = http;\n\nvar app = express();\nvar server = createServer(app);\nvar init = false;\n\nvar main = async () => {\n    app.use(cors({\n        \"origin\": \"*\",\n        \"methods\": \"GET,HEAD,PUT,PATCH,POST,DELETE\",\n        // \"preflightContinue\": false,\n        // \"optionsSuccessStatus\": 204\n    }));\n    app.use(bodyParser.json());\n\n    try {\n        server.listen(4081, '0.0.0.0', () => {\n            console.log(`GRAPHQL running in port ${4082}`)\n        });\n    } catch (err) {\n        console.log(err.message)\n    }\n\n    node.send({\n        server,\n        app\n    })\n\n    flow.set(\"webServer\", server);\n    flow.set(\"webApp\", app);\n\n}\n\ncontext.set(\"init\", async () => {\n    if (!init) {\n        await main();\n    };\n    init = true\n})\n\n",
        "finalize": "",
        "libs": [
            {
                "var": "express",
                "module": "express"
            },
            {
                "var": "http",
                "module": "http"
            },
            {
                "var": "bodyParser",
                "module": "body-parser"
            },
            {
                "var": "cors",
                "module": "cors"
            },
            {
                "var": "socketIo",
                "module": "socket.io"
            }
        ],
        "x": 920,
        "y": 200,
        "wires": [
            [
                "f5e035fc16e47ee6",
                "de8f9317fc9795bb",
                "1f9fd99e826b7486"
            ]
        ]
    },
    {
        "id": "1f9fd99e826b7486",
        "type": "function",
        "z": "ce9633b89106de8f",
        "name": "Start HTTP",
        "func": " \nvar emitter = new events.EventEmitter();\nemitter.setMaxListeners(0);\n\nlet returnQueue = 'http-response';\n\nconst app = flow.get(\"webApp\");\n\nvar addJob = await global.get(\"getQueue\")(\"query\"); \nawait node.status({\n        fill: \"red\",\n        shape: \"ring\",\n        text: \"Starting at: \" + new Date()\n    });\n\nconst processRequest = async function (req, res) {\n    let requestId = paralleldriveCuid2.createId();\n    await node.status({\n        fill: \"red\",\n        shape: \"ring\",\n        text: \"Processing at: \" + new Date() + \" \" + requestId\n    });\n    emitter.once(requestId, ({ type, payload }) => {\n        res.type('application/json');\n        switch (type) {\n            case 'data':\n                res.status(200)\n                res.send(payload)\n                break;\n            case 'error':\n                res.status(400)\n                res.send(payload)\n                break;\n        }\n        res.end();\n    });\n    addJob(requestId, {\n        id: requestId,\n        schema: req?.params?.schema,\n        payload: req.body,\n        context: { \n            headers: req.headers,\n            id: requestId,\n            replyTo: returnQueue\n         }\n    }, { jobId: requestId })\n};\n\napp.post(\"/:schema\", processRequest);\napp.post(\"/graphql/:schema\", processRequest);\n\nglobal.get(\"setWorker\")(returnQueue, async ( returnJob ) => {\n    emitter.emit( returnJob.name, returnJob.data );\n    return null\n}, { concurrency: 100 })\n\nawait node.status({\n    fill: \"green\",\n    shape: \"ring\",\n    text: \"Running at: \" + new Date()\n});\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "paralleldriveCuid2",
                "module": "@paralleldrive/cuid2"
            },
            {
                "var": "events",
                "module": "events"
            }
        ],
        "x": 1190,
        "y": 200,
        "wires": [
            []
        ]
    },
    {
        "id": "de8f9317fc9795bb",
        "type": "function",
        "z": "ce9633b89106de8f",
        "d": true,
        "name": "Start WS",
        "func": "await node.status({\n    fill: \"red\",\n    shape: \"ring\",\n    text: \"Starting at: \" + new Date()\n})\n\n\ntry {\n    var emitter = new events.EventEmitter();\n    emitter.setMaxListeners(0);\n    const { WebSocketServer, WebSocket } = ws;\n\n    let returnQueue = 'ws-response';\n\n    const app = flow.get(\"webApp\");\n    const server = flow.get(\"webServer\");\n\n    var addJob = await global.get(\"getQueue\")(\"ws\");\n    await node.status({\n        fill: \"red\",\n        shape: \"ring\",\n        text: \"Starting at: \" + new Date()\n    });\n\n    const wsServer = new WebSocketServer({ noServer: true });\n    wsServer.on(\"connection\", (cb, req) => {\n        try {\n            const { pathname } = url.parse(req.url || \"\");\n            console.log(pathname)\n            if (pathname !== '/socket.io/') {\n                cb.on(\"message\", async (data) => {\n                    console.log(\"ws\", pathname, data.toString())\n                    const { id, type, payload } = JSON.parse(data.toString());\n                    if (type === \"connection_init\") cb.send(JSON.stringify({ type: \"connection_ack\" }));\n                    else if (type === \"subscribe\") {\n                        const requestId = paralleldriveCuid2.createId();\n                        emitter.on(requestId, ({ type: tRes, payload }) => {\n                            if (tRes == \"data\") {\n                                cb.send(JSON.stringify({ id, type: \"next\", payload }));\n                            } else {\n                                cb.send(JSON.stringify({\n                                    id, type: tRes, payload: payload.errors\n                                }));\n                            }\n                        });\n                        addJob(requestId, {\n                            id: requestId,\n                            schema: pathname.split(\"/\").pop(),\n                            payload: payload,\n                            context: {\n                                headers: {},\n                                id: requestId,\n                                replyTo: returnQueue\n                            }\n                        }, { jobId: requestId })\n                    }\n                });\n            }\n            cb.on(\"close\", () => {\n\n            });\n        } catch (err) {\n            console.error(err.message)\n        }\n    });\n\n    server.on(\"upgrade\", (req, socket, head) => {\n        wsServer.handleUpgrade(req, socket, head, wsObject => {\n            wsServer.emit('connection', wsObject, req);\n        })\n    });\n\n    global.get(\"setWorker\")(returnQueue, async (returnJob) => {\n        emitter.emit(returnJob.id, returnJob.data);\n        return null\n    }, { concurrency: 100 })\n\n    await node.status({\n        fill: \"green\",\n        shape: \"ring\",\n        text: \"Running at: \" + new Date()\n    });\n\n} catch (err) {\n    node.error(\"my error message\", err);\n}",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "paralleldriveCuid2",
                "module": "@paralleldrive/cuid2"
            },
            {
                "var": "events",
                "module": "events"
            },
            {
                "var": "ws",
                "module": "ws"
            },
            {
                "var": "url",
                "module": "url"
            }
        ],
        "x": 1180,
        "y": 400,
        "wires": [
            []
        ]
    },
    {
        "id": "f5e035fc16e47ee6",
        "type": "function",
        "z": "ce9633b89106de8f",
        "name": "Start SocketIO",
        "func": "await node.status({\n    fill: \"red\",\n    shape: \"ring\",\n    text: \"Starting at: \" + new Date()\n})\n\nvar emitter = new events.EventEmitter();\nemitter.setMaxListeners(0);\nconst { Server: SocketIOServer, Socket } = socketIo;\n\nlet returnQueue = 'socket-response';\n\nconst app = flow.get(\"webApp\");\nconst server = flow.get(\"webServer\");\n\nvar addJob = await global.get(\"getQueue\")(\"socket\"); \nawait node.status({\n        fill: \"red\",\n        shape: \"ring\",\n        text: \"Starting at: \" + new Date()\n    });\n\nconst io = new SocketIOServer( server, {\n    // perMessageDeflate: {\n    //     threshold: 1024,\n    //     zlibDeflateOptions: {\n    //         level: 6,\n    //     },\n    //     zlibInflateOptions: {\n    //         chunkSize: 8 * 1024,\n    //     },\n    // },\n    pingInterval: 2000,\n    pingTimeout: 10000,\n    maxHttpBufferSize: 1e8,\n    cors: { origin: \"*\" },\n    httpCompression: { threshold: 1024, chunkSize: 8 * 1024, windowBits: 14, memLevel: 7 }\n});\n\nconst dynamicNamespacePattern = /^\\/dynamic-\\w+$/; // Ví dụ: /dynamic-abc, /dynamic-123\n\nconst processSocketRequest = (socket) => {\n  // Khi một client kết nối thành công vào một namespace khớp với mẫu regex\n  console.log(`User connected to a dynamic namespace: ${socket.nsp.name}`);\n\n  socket.on('data', ({ id, type, payload }) => {\n    try {\n      console.log('sock', id, type, payload)\n      let path = socket.nsp.name;\n      let requestId = paralleldriveCuid2.createId();\n      if (type === \"connection_init\") socket.compress(true).emit('data', { id, type: 'connection_ack' });\n      else if ([\"query\", \"subscription\", \"start\", \"patch\"].includes(type)) {\n        addJob(requestId, {\n          id: requestId,\n          schema: path.split('/').slice(-1)[0],\n          payload: JSON.parse(payload),\n          context: {\n            headers: {},\n            id: requestId,\n            replyTo: returnQueue\n          }\n        }, { jobId: requestId });\n        emitter.on(requestId, ({ type: tRes, payload: pRes }) => {\n            if (tRes == \"data\") {\n                socket.compress(true).emit('data', { id, type: 'data', payload: pRes });\n            } else {\n              socket.compress(true).emit('data', { id, type: tRes, payload: pRes });\n            }\n        });\n      } else if ([\"stop\", \"complete\"].includes(type)) {\n        socket.compress(true).emit('data', { id, type });\n      } else {\n          socket.compress(true).emit('data', { id, type: 'error', payload: { errors: [{ message: \"'type' is not defined!\" }] } });\n      }\n    } catch (err) {\n      socket.compress(true).emit('data', { id, type: 'error', payload: { errors: [{ message: err.message }] } });\n    }\n    \n    console.log(`Message from ${socket.nsp.name}:`);\n    // Bạn có thể phát sự kiện trở lại chỉ cho namespace đó\n    // socket.nsp.emit('message', `Echo from ${socket.nsp.name}: ${msg}`);\n  });\n\n  socket.on('disconnect', () => {\n    console.log(`User disconnected from a dynamic namespace: ${socket.nsp.name}`);\n  });\n}\n\n// Sử dụng hàm trong io.of() để kiểm tra namespace\nconst dynamicNamespace = io.of((name, auth, next) => {\n  // 'name' là tên namespace mà client đang cố gắng kết nối\n  console.log(name, \"dynamic anme\")\n    next(null, true); // (error, success)\n});\n\ndynamicNamespace.on('connection', processSocketRequest);\n\nglobal.get(\"setWorker\")(returnQueue, async ( returnJob ) => {\n    emitter.emit( returnJob.name, returnJob.data );\n    return null\n}, { concurrency: 100 })\n\nawait node.status({\n    fill: \"green\",\n    shape: \"ring\",\n    text: \"Running at: \" + new Date()\n});\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "paralleldriveCuid2",
                "module": "@paralleldrive/cuid2"
            },
            {
                "var": "events",
                "module": "events"
            },
            {
                "var": "url",
                "module": "url"
            },
            {
                "var": "socketIo",
                "module": "socket.io"
            }
        ],
        "x": 1200,
        "y": 320,
        "wires": [
            []
        ]
    },
    {
        "id": "291ce05e87428530",
        "type": "join",
        "z": "ce9633b89106de8f",
        "name": "Compile",
        "mode": "custom",
        "build": "array",
        "property": "",
        "propertyType": "full",
        "key": "topic",
        "joiner": "\\n",
        "joinerType": "str",
        "useparts": true,
        "accumulate": false,
        "timeout": "",
        "count": "3",
        "reduceRight": false,
        "reduceExp": "",
        "reduceInit": "",
        "reduceInitType": "num",
        "reduceFixup": "",
        "x": 690,
        "y": 220,
        "wires": [
            [
                "1a27e765d2407d77"
            ]
        ]
    },
    {
        "id": "eb79cd1582384a1d",
        "type": "function",
        "z": "ce9633b89106de8f",
        "name": "function 8",
        "func": "\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 140,
        "y": 200,
        "wires": [
            [
                "5ad5f579311f38d9",
                "bd74bb073967c5c3",
                "6eaf2b063f6c6d2c"
            ]
        ]
    },
    {
        "id": "bd74bb073967c5c3",
        "type": "subflow:5ed478d1a62e4007",
        "z": "ce9633b89106de8f",
        "name": "",
        "x": 390,
        "y": 360,
        "wires": [
            [
                "291ce05e87428530"
            ]
        ]
    },
    {
        "id": "6eaf2b063f6c6d2c",
        "type": "subflow:1e273549eda8541e",
        "z": "ce9633b89106de8f",
        "name": "",
        "env": [
            {
                "name": "REDIS_CONNECTION",
                "value": "REDIS_CONNECTION",
                "type": "env"
            }
        ],
        "x": 390,
        "y": 260,
        "wires": [
            [
                "291ce05e87428530"
            ]
        ]
    },
    {
        "id": "2b788bfb99ec220f",
        "type": "inject",
        "z": "09922ee65be58345",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 240,
        "y": 340,
        "wires": [
            [
                "8c142f4f14642e77"
            ]
        ]
    },
    {
        "id": "8c142f4f14642e77",
        "type": "function",
        "z": "09922ee65be58345",
        "name": "function 3",
        "func": "const Binance = nodeBinanceApi;\n\nconst API_KEY = 'ixdXvqni0TsSpwFThki6Rd7YPEMn0aHj0opux4wGBWI5ZZ0YeVopxS4pah2PY3xd';\nconst API_SECRET = 'DVguRPa7IQTy5tCmFzSsJhFvHzGf5xbabGHYccNegafDOumb24VoC5VrKF5ezB38';\n\nconst binance = new Binance().options({\n    APIKEY: API_KEY,\n    APISECRET: API_SECRET,\n    // Đặt test: true nếu bạn muốn thử nghiệm trên mạng thử nghiệm của Binance\n    // test: true, \n});\n\nconst symbol = 'MEMEUSDT';\n\n// --- 1. Lấy giá MEMEUSDT Futures theo thời gian thực ---\nfunction getFuturesRealTimePrice() {\n    binance.futuresSubscribe('MEMEUSDT@aggTrade', (trades) => {\n        console.log(`Giá Futures ${trades.s}: ${trades.p}`);\n    });\n}\n\n// --- 2. Mở vị thế Long (Mua) - Market Order ---\n// side: 'BUY', positionSide: 'LONG'\nasync function openLongPosition(quantity) {\n    try {\n        console.log(`🚀 Đang mở vị thế LONG ${quantity} ${symbol}...`);\n        // Đối với Futures, bạn cần chỉ định `side` và `positionSide`\n        let order = await binance.futuresMarketBuy(symbol, quantity, { positionSide: 'LONG' });\n        console.log(\"✅ Mở vị thế LONG thành công:\");\n        console.log(order);\n        if (order.code) { // Binance trả về lỗi dưới dạng object có key 'code'\n            console.error(\"Lỗi:\", order.msg);\n        }\n        return order;\n    } catch (error) {\n        console.error(\"❌ Lỗi khi mở vị thế LONG:\", error.body || error);\n    }\n}\n\n// --- 3. Mở vị thế Short (Bán) - Market Order ---\n// side: 'SELL', positionSide: 'SHORT'\nasync function openShortPosition(quantity) {\n    try {\n        console.log(`🚀 Đang mở vị thế SHORT ${quantity} ${symbol}...`);\n        let order = await binance.futuresMarketSell(symbol, quantity, { positionSide: 'SHORT' });\n        console.log(\"✅ Mở vị thế SHORT thành công:\");\n        console.log(order);\n        if (order.code) {\n            console.error(\"Lỗi:\", order.msg);\n        }\n        return order;\n    } catch (error) {\n        console.error(\"❌ Lỗi khi mở vị thế SHORT:\", error.body || error);\n    }\n}\n\n// --- 4. Lấy danh sách các vị thế đang mở ---\nasync function getOpenPositions() {\n    try {\n        console.log(\"🔍 Đang lấy danh sách các vị thế đang mở...\");\n        let positions = await binance.futuresPositionRisk();\n        // Lọc ra các vị thế có số lượng khác 0\n        const openPositions = positions.filter(pos => parseFloat(pos.positionAmt) !== 0);\n\n        if (openPositions.length > 0) {\n            console.log(\"📊 Các vị thế đang mở:\");\n            openPositions.forEach(pos => {\n                console.log(\n                    `- Symbol: ${pos.symbol}, ` +\n                    `Số lượng: ${pos.positionAmt}, ` +\n                    `Giá vào lệnh: ${pos.entryPrice}, ` +\n                    `PNL chưa thực hiện: ${pos.unRealizedProfit}`\n                );\n            });\n        } else {\n            console.log(\"Không có vị thế nào đang mở.\");\n        }\n\n        return openPositions;\n    } catch (error) {\n        console.error(\"❌ Lỗi khi lấy danh sách vị thế:\", error.body || error);\n    }\n}\n\n// --- 5. Hủy một lệnh Futures đang chờ khớp ---\n// Lưu ý: Thao tác này để hủy một lệnh CHƯA KHỚP (ví dụ: limit order), không phải để đóng vị thế.\nasync function cancelFutureOrder(orderId) {\n    try {\n        console.log(`🗑️ Đang hủy lệnh Futures có ID: ${orderId}...`);\n        let result = await binance.futuresCancel(symbol, { orderId: orderId });\n        console.log(\"✅ Hủy lệnh thành công:\");\n        console.log(result);\n        return result;\n    } catch (error) {\n        console.error(\"❌ Lỗi khi hủy lệnh Futures:\", error.body || error);\n    }\n}\n\n\n// --- Hàm chính để chạy các chức năng ---\nasync function main() {\n    // Bắt đầu theo dõi giá Futures\n    getFuturesRealTimePrice();\n\n    // ----- VÍ DỤ VỀ CÁC HÀNH ĐỘNG VỚI FUTURES -----\n    // Bạn có thể bỏ comment các dòng dưới đây để thử nghiệm\n\n    // Ví dụ 1: Mở vị thế LONG với số lượng 10 MEME\n    // await openLongPosition(10);\n\n    // Ví dụ 2: Mở vị thế SHORT với số lượng 10 MEME\n    // await openShortPosition(10);\n\n    // Ví dụ 3: Lấy danh sách tất cả các vị thế đang mở\n    await getOpenPositions();\n\n    // Ví dụ 4: Hủy một lệnh limit đang chờ (bạn cần có orderId của lệnh đó)\n    // await cancelFutureOrder('your_limit_order_id');\n}\n\nmain();\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "nodeBinanceApi",
                "module": "node-binance-api"
            }
        ],
        "x": 460,
        "y": 340,
        "wires": [
            []
        ]
    },
    {
        "id": "c0db84696cc1b834",
        "type": "function",
        "z": "a52209a7262ea19f",
        "name": "Start Emitter",
        "func": "( async () => {\n    await node.status({\n        fill: \"red\",\n        shape: \"ring\",\n        text: \"Starting\"\n    })\n    var emitter = new events.EventEmitter();\n    emitter.setMaxListeners(0);\n    await flow.set(\"emitter\", emitter);\n    await node.status({\n        fill: \"red\",\n        shape: \"ring\",\n        text: \"Running\"\n    });\n    node.send({})\n})()\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "events",
                "module": "events"
            }
        ],
        "x": 370,
        "y": 80,
        "wires": [
            [
                "17b13be6b823c221"
            ]
        ],
        "icon": "node-red/arrow-in.svg"
    },
    {
        "id": "e0be9b659f69866d",
        "type": "function",
        "z": "a52209a7262ea19f",
        "name": "Start WebSerer",
        "func": "\nawait node.status({\n    fill: \"red\",\n    shape: \"ring\",\n    text: \"Starting at: \" + new Date()\n})\nawait context.get(\"init\")()\nawait node.status({\n    fill: \"red\",\n    shape: \"ring\",\n    text: \"Running at: \" + new Date()\n});\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "const { createServer, request } = http;\n\nvar app = express();\nvar server = createServer(app);\nvar init = false;\n\nvar main = async () => {\n    app.use(cors({\n        \"origin\": \"*\",\n        \"methods\": \"GET,HEAD,PUT,PATCH,POST,DELETE\",\n        // \"preflightContinue\": false,\n        // \"optionsSuccessStatus\": 204\n    }));\n    app.use(bodyParser.json());\n\n    try {\n        server.listen(4081, '0.0.0.0', () => {\n            console.log(`GRAPHQL running in port ${4082}`)\n        });\n    } catch (err) {\n        console.log(err.message)\n    }\n\n    node.send({\n        server,\n        app\n    })\n\n    flow.set(\"webServer\", server);\n    flow.set(\"webApp\", app);\n\n}\n\ncontext.set(\"init\", async () => {\n    if (!init) {\n        await main();\n    };\n    init = true\n})\n\n",
        "finalize": "",
        "libs": [
            {
                "var": "express",
                "module": "express"
            },
            {
                "var": "http",
                "module": "http"
            },
            {
                "var": "bodyParser",
                "module": "body-parser"
            },
            {
                "var": "cors",
                "module": "cors"
            },
            {
                "var": "socketIo",
                "module": "socket.io"
            }
        ],
        "x": 140,
        "y": 300,
        "wires": [
            [
                "5e6f6312ae208896",
                "67147e1ee896d93f",
                "fb17081cd30510f6",
                "bde4a9bdb9061a3b"
            ]
        ]
    },
    {
        "id": "fb17081cd30510f6",
        "type": "function",
        "z": "a52209a7262ea19f",
        "name": "Start HTTP",
        "func": " \nvar emitter = new events.EventEmitter();\nemitter.setMaxListeners(0);\n\nlet returnQueue = 'http-response-' + paralleldriveCuid2.createId();\n\nconst app = flow.get(\"webApp\");\n\nvar addJob = await global.get(\"getQueue\")(\"query\"); \nawait node.status({\n        fill: \"red\",\n        shape: \"ring\",\n        text: \"Starting at: \" + new Date()\n    });\n\nconst processRequest = async function (req, res) {\n    let requestId = paralleldriveCuid2.createId();\n    await node.status({\n        fill: \"red\",\n        shape: \"ring\",\n        text: \"Processing at: \" + new Date() + \" \" + requestId\n    });\n    emitter.once(requestId, ({ type, payload }) => {\n        res.type('application/json');\n        switch (type) {\n            case 'data':\n                res.status(200)\n                res.send(payload)\n                break;\n            case 'error':\n                res.status(400)\n                res.send(payload)\n                break;\n        }\n        res.end();\n    });\n    addJob(requestId, {\n        id: requestId,\n        schema: req?.params?.schema,\n        payload: req.body,\n        context: { \n            headers: req.headers,\n            id: requestId,\n            replyTo: returnQueue\n         }\n    }, { jobId: requestId })\n};\n\napp.post(\"/:schema\", processRequest);\napp.post(\"/graphql/:schema\", processRequest);\n\nglobal.get(\"setWorker\")(returnQueue, async ( returnJob ) => {\n    emitter.emit( returnJob.name, returnJob.data );\n    return null\n}, { concurrency: 100 })\n\nawait node.status({\n    fill: \"green\",\n    shape: \"ring\",\n    text: \"Running at: \" + new Date()\n});\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "paralleldriveCuid2",
                "module": "@paralleldrive/cuid2"
            },
            {
                "var": "events",
                "module": "events"
            }
        ],
        "x": 370,
        "y": 320,
        "wires": [
            []
        ]
    },
    {
        "id": "67147e1ee896d93f",
        "type": "function",
        "z": "a52209a7262ea19f",
        "d": true,
        "name": "Start WS",
        "func": "await node.status({\n    fill: \"red\",\n    shape: \"ring\",\n    text: \"Starting at: \" + new Date()\n})\n\n\ntry {\n    var emitter = new events.EventEmitter();\n    emitter.setMaxListeners(0);\n    const { WebSocketServer, WebSocket } = ws;\n\n    let returnQueue = 'ws-response';\n\n    const app = flow.get(\"webApp\");\n    const server = flow.get(\"webServer\");\n\n    var addJob = await global.get(\"getQueue\")(\"ws\");\n    await node.status({\n        fill: \"red\",\n        shape: \"ring\",\n        text: \"Starting at: \" + new Date()\n    });\n\n    const wsServer = new WebSocketServer({ noServer: true });\n    wsServer.on(\"connection\", (cb, req) => {\n        try {\n            const { pathname } = url.parse(req.url || \"\");\n            console.log(pathname)\n            if (pathname !== '/socket.io/') {\n                cb.on(\"message\", async (data) => {\n                    console.log(\"ws\", pathname, data.toString())\n                    const { id, type, payload } = JSON.parse(data.toString());\n                    if (type === \"connection_init\") cb.send(JSON.stringify({ type: \"connection_ack\" }));\n                    else if (type === \"subscribe\") {\n                        const requestId = paralleldriveCuid2.createId();\n                        emitter.on(requestId, ({ type: tRes, payload }) => {\n                            if (tRes == \"data\") {\n                                cb.send(JSON.stringify({ id, type: \"next\", payload }));\n                            } else {\n                                cb.send(JSON.stringify({\n                                    id, type: tRes, payload: payload.errors\n                                }));\n                            }\n                        });\n                        addJob(requestId, {\n                            id: requestId,\n                            schema: pathname.split(\"/\").pop(),\n                            payload: payload,\n                            context: {\n                                headers: {},\n                                id: requestId,\n                                replyTo: returnQueue\n                            }\n                        }, { jobId: requestId })\n                    }\n                });\n            }\n            cb.on(\"close\", () => {\n\n            });\n        } catch (err) {\n            console.error(err.message)\n        }\n    });\n\n    server.on(\"upgrade\", (req, socket, head) => {\n        wsServer.handleUpgrade(req, socket, head, wsObject => {\n            wsServer.emit('connection', wsObject, req);\n        })\n    });\n\n    global.get(\"setWorker\")(returnQueue, async (returnJob) => {\n        emitter.emit(returnJob.id, returnJob.data);\n        return null\n    }, { concurrency: 100 })\n\n    await node.status({\n        fill: \"green\",\n        shape: \"ring\",\n        text: \"Running at: \" + new Date()\n    });\n\n} catch (err) {\n    node.error(\"my error message\", err);\n}",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "paralleldriveCuid2",
                "module": "@paralleldrive/cuid2"
            },
            {
                "var": "events",
                "module": "events"
            },
            {
                "var": "ws",
                "module": "ws"
            },
            {
                "var": "url",
                "module": "url"
            }
        ],
        "x": 360,
        "y": 440,
        "wires": [
            []
        ]
    },
    {
        "id": "5e6f6312ae208896",
        "type": "function",
        "z": "a52209a7262ea19f",
        "name": "Start SocketIO",
        "func": "await node.status({\n    fill: \"red\",\n    shape: \"ring\",\n    text: \"Starting at: \" + new Date()\n})\n\nvar emitter = new events.EventEmitter();\nemitter.setMaxListeners(0);\nconst { Server: SocketIOServer, Socket } = socketIo;\n\nlet returnQueue = 'socket-response' + paralleldriveCuid2.createId();\n\nconst app = flow.get(\"webApp\");\nconst server = flow.get(\"webServer\");\n\nvar addJob = await global.get(\"getQueue\")(\"socket\"); \nawait node.status({\n        fill: \"red\",\n        shape: \"ring\",\n        text: \"Starting at: \" + new Date()\n    });\n\nconst io = new SocketIOServer( server, {\n    // perMessageDeflate: {\n    //     threshold: 1024,\n    //     zlibDeflateOptions: {\n    //         level: 6,\n    //     },\n    //     zlibInflateOptions: {\n    //         chunkSize: 8 * 1024,\n    //     },\n    // },\n    pingInterval: 2000,\n    pingTimeout: 10000,\n    maxHttpBufferSize: 1e8,\n    cors: { origin: \"*\" },\n    httpCompression: { threshold: 1024, chunkSize: 8 * 1024, windowBits: 14, memLevel: 7 }\n});\n\nconst dynamicNamespacePattern = /^\\/dynamic-\\w+$/; // Ví dụ: /dynamic-abc, /dynamic-123\n\nconst processSocketRequest = (socket) => {\n  // Khi một client kết nối thành công vào một namespace khớp với mẫu regex\n  console.log(`User connected to a dynamic namespace: ${socket.nsp.name}`);\n\n  socket.on('data', ({ id, type, payload }) => {\n    try {\n      console.log('sock', id, type, payload)\n      let path = socket.nsp.name;\n      let requestId = paralleldriveCuid2.createId();\n      if (type === \"connection_init\") socket.compress(true).emit('data', { id, type: 'connection_ack' });\n      else if ([\"query\", \"subscription\", \"start\", \"patch\"].includes(type)) {\n        addJob(requestId, {\n          id: requestId,\n          schema: path.split('/').slice(-1)[0],\n          payload: JSON.parse(payload),\n          context: {\n            headers: {},\n            id: requestId,\n            replyTo: returnQueue\n          }\n        }, { jobId: requestId });\n        emitter.on(requestId, ({ type: tRes, payload: pRes }) => {\n            if (tRes == \"data\") {\n                socket.compress(true).emit('data', { id, type: 'data', payload: pRes });\n            } else {\n              socket.compress(true).emit('data', { id, type: tRes, payload: pRes });\n            }\n        });\n      } else if ([\"stop\", \"complete\"].includes(type)) {\n        socket.compress(true).emit('data', { id, type });\n      } else {\n          socket.compress(true).emit('data', { id, type: 'error', payload: { errors: [{ message: \"'type' is not defined!\" }] } });\n      }\n    } catch (err) {\n      socket.compress(true).emit('data', { id, type: 'error', payload: { errors: [{ message: err.message }] } });\n    }\n    \n    console.log(`Message from ${socket.nsp.name}:`);\n    // Bạn có thể phát sự kiện trở lại chỉ cho namespace đó\n    // socket.nsp.emit('message', `Echo from ${socket.nsp.name}: ${msg}`);\n  });\n\n  socket.on('disconnect', () => {\n    console.log(`User disconnected from a dynamic namespace: ${socket.nsp.name}`);\n  });\n}\n\n// Sử dụng hàm trong io.of() để kiểm tra namespace\nconst dynamicNamespace = io.of((name, auth, next) => {\n  // 'name' là tên namespace mà client đang cố gắng kết nối\n  console.log(name, \"dynamic anme\")\n    next(null, true); // (error, success)\n});\n\ndynamicNamespace.on('connection', processSocketRequest);\n\nglobal.get(\"setWorker\")(returnQueue, async ( returnJob ) => {\n    emitter.emit( returnJob.name, returnJob.data );\n    return null\n}, { concurrency: 100 })\n\nawait node.status({\n    fill: \"green\",\n    shape: \"ring\",\n    text: \"Running at: \" + new Date()\n});\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "paralleldriveCuid2",
                "module": "@paralleldrive/cuid2"
            },
            {
                "var": "events",
                "module": "events"
            },
            {
                "var": "url",
                "module": "url"
            },
            {
                "var": "socketIo",
                "module": "socket.io"
            }
        ],
        "x": 380,
        "y": 380,
        "wires": [
            []
        ]
    },
    {
        "id": "17b13be6b823c221",
        "type": "join",
        "z": "a52209a7262ea19f",
        "name": "Compile",
        "mode": "custom",
        "build": "array",
        "property": "",
        "propertyType": "full",
        "key": "topic",
        "joiner": "\\n",
        "joinerType": "str",
        "useparts": true,
        "accumulate": false,
        "timeout": "",
        "count": "3",
        "reduceRight": false,
        "reduceExp": "",
        "reduceInit": "",
        "reduceInitType": "num",
        "reduceFixup": "",
        "x": 690,
        "y": 200,
        "wires": [
            [
                "e0be9b659f69866d"
            ]
        ]
    },
    {
        "id": "88271cb98fbef6b7",
        "type": "function",
        "z": "a52209a7262ea19f",
        "name": "function 8",
        "func": "\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 120,
        "y": 200,
        "wires": [
            [
                "c0db84696cc1b834",
                "82db55a73ed7cf82",
                "fbfe01dbb99abb1c"
            ]
        ]
    },
    {
        "id": "82db55a73ed7cf82",
        "type": "subflow:5ed478d1a62e4007",
        "z": "a52209a7262ea19f",
        "name": "",
        "x": 390,
        "y": 200,
        "wires": [
            [
                "17b13be6b823c221"
            ]
        ]
    },
    {
        "id": "fbfe01dbb99abb1c",
        "type": "subflow:1e273549eda8541e",
        "z": "a52209a7262ea19f",
        "name": "",
        "env": [
            {
                "name": "REDIS_CONNECTION",
                "value": "REDIS_CONNECTION",
                "type": "env"
            }
        ],
        "x": 390,
        "y": 140,
        "wires": [
            [
                "17b13be6b823c221"
            ]
        ]
    },
    {
        "id": "9a00fd0253f8665e",
        "type": "inject",
        "z": "a52209a7262ea19f",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 130,
        "y": 40,
        "wires": [
            [
                "88271cb98fbef6b7"
            ]
        ]
    },
    {
        "id": "1a36bddb3091b1ba",
        "type": "inject",
        "z": "a52209a7262ea19f",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": "1",
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 130,
        "y": 100,
        "wires": [
            [
                "88271cb98fbef6b7"
            ]
        ]
    },
    {
        "id": "bde4a9bdb9061a3b",
        "type": "function",
        "z": "a52209a7262ea19f",
        "name": "Start Upload",
        "func": "const {\n  S3Client,\n  PutObjectCommand,\n} = awsSdkClientS3;\n\nconst { Upload } = awsSdkLibStorage;\n\n// File sẽ được lưu tạm thời dưới dạng Buffer trong RAM (req.file.buffer)\nconst storage = multer.memoryStorage();\nconst upload = multer({\n  storage: storage,\n  // Cảnh báo: Thiết lập giới hạn file lớn để kiểm tra Multipart Upload\n  limits: { fileSize: 50 * 1024 * 1024 } // Ví dụ: giới hạn 50MB\n});\n\nconst ACCOUNT_ID = \"cabeebbd339be94fb532e563a50ffd18\";\nconst ACCESS_KEY_ID = \"6fb7e17a9d03336755e649f2af7feaa6\";\nconst SECRET_ACCESS_KEY = \"797ef419d1d6ecb177cd968c4ce74dcecfaf5af67bd98cc8aac61fd442d84e2c\";\nconst BUCKET_NAME = 'dudu-bucket';\n\nconst S3 = new S3Client({\n  region: \"auto\",\n  endpoint: `https://${ACCOUNT_ID}.r2.cloudflarestorage.com`,\n  credentials: {\n    accessKeyId: ACCESS_KEY_ID,\n    secretAccessKey: SECRET_ACCESS_KEY,\n  },\n});\n\nconst Formidable = formidable;\n\nvar emitter = new events.EventEmitter();\nemitter.setMaxListeners(0);\n\nlet returnQueue = 'http-response-' + paralleldriveCuid2.createId();\n\nconst app = flow.get(\"webApp\");\n\nvar addJob = await global.get(\"getQueue\")(\"query\"); \nawait node.status({\n        fill: \"red\",\n        shape: \"ring\",\n        text: \"Starting at: \" + new Date()\n    });\n\nfunction shouldUseBase64(mimeType) {\n  const binaryMimeRegex = /^(audio|video|image|application\\/(pdf|zip|rar|tar|gzip|bzip2|octet-stream|msword|vnd\\.openxmlformats-officedocument))/i;\n  return binaryMimeRegex.test(mimeType);\n}\n\nconst processUpload = async function (req, res) {\n    let requestId = paralleldriveCuid2.createId();\n    \n    try {\n      if (!req.file) {\n        return res.status(400).send('No file uploaded.');\n      }\n\n      const file = req.file;\n      // Sử dụng tên file gốc (file.originalname) với UUID để đảm bảo tính duy nhất\n      const fileKey = `${requestId}-${file.originalname}`;\n\n      // Khởi tạo Upload với S3Client và các tham số\n      const parallelUploads = new Upload({\n        client: S3,\n        params: {\n          Bucket: BUCKET_NAME,\n          Key: fileKey,\n          Body: file.buffer,\n          // ContentType lấy tự động từ Multer (VD: application/pdf, video/mp4)\n          ContentType: file.mimetype,\n          ACL: 'public-read'\n        },\n        // Cấu hình cho Multipart Upload \n        queueSize: 4,\n        partSize: 5 * 1024 * 1024,\n      });\n\n      // Chờ quá trình upload hoàn tất\n      const data = await parallelUploads.done();\n\n      res.status(200).json({\n        message: `Tệp (${file.mimetype}) đã được upload thành công!`,\n        url: data.Location,\n        size: file.size,\n      });\n    } catch (error) {\n      console.error('Lỗi khi upload tệp:', error);\n      res.status(500).send('Lỗi khi upload tệp lên S3: ' + error.message);\n    }\n\n    await node.status({\n        fill: \"red\",\n        shape: \"ring\",\n        text: \"Processing at: \" + new Date() + \" \" + requestId\n    });\n    emitter.once(requestId, ({ type, payload }) => {\n        res.type('application/json');\n        switch (type) {\n            case 'data':\n                res.status(200)\n                res.send(payload)\n                break;\n            case 'error':\n                res.status(400)\n                res.send(payload)\n                break;\n        }\n        res.end();\n    });\n    addJob(requestId, {\n        id: requestId,\n        schema: req?.params?.schema,\n        payload: req.body,\n        context: { \n            headers: req.headers,\n            id: requestId,\n            replyTo: returnQueue\n         }\n    }, { jobId: requestId })\n};\n\napp.post(\"/api/upload\", upload.single('file'), processUpload);\n\nglobal.get(\"setWorker\")(returnQueue, async ( returnJob ) => {\n    emitter.emit( returnJob.name, returnJob.data );\n    return null\n}, { concurrency: 100 })\n\nawait node.status({\n    fill: \"green\",\n    shape: \"ring\",\n    text: \"Running at: \" + new Date()\n});\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "paralleldriveCuid2",
                "module": "@paralleldrive/cuid2"
            },
            {
                "var": "events",
                "module": "events"
            },
            {
                "var": "formidable",
                "module": "formidable"
            },
            {
                "var": "awsSdkClientS3",
                "module": "@aws-sdk/client-s3"
            },
            {
                "var": "multer",
                "module": "multer"
            },
            {
                "var": "awsSdkLibStorage",
                "module": "@aws-sdk/lib-storage"
            }
        ],
        "x": 390,
        "y": 600,
        "wires": [
            []
        ]
    },
    {
        "id": "077a097d084ee3cf",
        "type": "inject",
        "z": "772c07f1f620c995",
        "name": "Start Dashboard",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": "0",
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 230,
        "y": 200,
        "wires": [
            [
                "13cad733cce4b8e0"
            ]
        ]
    },
    {
        "id": "13cad733cce4b8e0",
        "type": "function",
        "z": "772c07f1f620c995",
        "name": "Build Dashboard",
        "func": "const redis = new IORedis(env.get(\"REDIS_URL\") || env.get(\"REDIS_CONNECTION\"), { maxRetriesPerRequest: null });\n\nlet Queue = bullmq.Queue;\nlet createBullBoard = bullBoardApi.createBullBoard;\nlet BullAdapter = bullBoardApiBullAdapter.BullAdapter;\nlet BullMQAdapter = bullBoardApiBullMQAdapter.BullMQAdapter;\nlet ExpressAdapter = bullBoardExpress.ExpressAdapter;\n\nvar queueNameSet = new Set();\n\nasync function discoverQueues() {\n    const keys = await redis.keys('bull:*:id');\n    const queueNames = keys.map(k => k.split(':')[1]);\n    const uniqueQueueNames = Array.from(new Set(queueNames)).filter(name => !queueNameSet.has(name));\n    queueNameSet = new Set([...queueNameSet, ...uniqueQueueNames]);\n    return uniqueQueueNames.map(name => new Queue(name, { connection: redis }));\n}\n\nconst serverAdapter = new ExpressAdapter();\nserverAdapter.setBasePath('/admin/queues');\nconst app = express();\n\napp.use('/admin/queues', serverAdapter.getRouter());\n\nconst { addQueue, removeQueue, setQueues, replaceQueues } = createBullBoard({\n    //   queues: [new BullAdapter(someQueue), new BullAdapter(someOtherQueue), new BullMQAdapter(queueMQ)],\n    queues: [],\n    serverAdapter: serverAdapter,\n});\nsetInterval(function () {\n    discoverQueues().then(queueNames => {\n        node.status({\n            fill: \"green\",\n            shape: \"ring\",\n            text: queueNames.join(\" | \")\n        })\n        queueNames.forEach(function (item) {\n            setQueues([new BullMQAdapter(item)])\n        })\n    })\n}, 1000);\n\napp.listen(15666, () => {\n    console.log('Running on 15666...');\n    console.log('For the UI, open http://localhost:5666/admin/queues');\n    console.log('Make sure Redis is running on port 6379 by default');\n});\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "IORedis",
                "module": "ioredis"
            },
            {
                "var": "express",
                "module": "express"
            },
            {
                "var": "bullmq",
                "module": "bullmq"
            },
            {
                "var": "bullBoardApi",
                "module": "@bull-board/api"
            },
            {
                "var": "bullBoardApiBullAdapter",
                "module": "@bull-board/api/bullAdapter"
            },
            {
                "var": "bullBoardApiBullMQAdapter",
                "module": "@bull-board/api/bullMQAdapter"
            },
            {
                "var": "bullBoardExpress",
                "module": "@bull-board/express"
            },
            {
                "var": "bull",
                "module": "bull"
            }
        ],
        "x": 510,
        "y": 200,
        "wires": [
            []
        ]
    },
    {
        "id": "e70dc72a79fb3b7e",
        "type": "function",
        "z": "c23a997595de5280",
        "name": "Config Private And Protected Tables",
        "func": "msg.topic = \"configTables\";\nmsg.payload = {\n    private: [\n        {\n            \"id\": \"relation\",\n            \"columns\": [\n                {\n                    \"id\": \"field\",\n                    \"type\": \"3\",\n                    \"required\": true\n                },\n                {\n                    \"id\": \"reference\",\n                    \"type\": \"3\",\n                    \"required\": true\n                },\n                {\n                    \"id\": \"column_id\",\n                    \"type\": \"3\",\n                    \"required\": true\n                },\n                {\n                    \"id\": \"column\",\n                    \"type\": \"column\",\n                    \"relations\": [\n                        {\n                            \"field\": \"column_id\",\n                            \"reference\": \"id\"\n                        }\n                    ]\n                }\n            ],\n            \"schema\": \"private\"\n        },\n        {\n            \"id\": \"table\",\n            \"columns\": [\n                {\n                    \"id\": \"name\",\n                    \"name\": \"name\",\n                    \"type\": \"3\"\n                },\n                {\n                    \"id\": \"schema\",\n                    \"name\": \"schema\",\n                    \"type\": \"3\",\n                    \"required\": false\n                },\n                {\n                    \"id\": \"getter\",\n                    \"name\": \"getter\",\n                    \"type\": \"3\"\n                },\n                {\n                    \"id\": \"setter\",\n                    \"name\": \"setter\",\n                    \"type\": \"3\"\n                },\n                {\n                    \"id\": \"format\",\n                    \"name\": \"format\",\n                    \"type\": \"3\"\n                },\n                {\n                    \"id\": \"columns\",\n                    \"name\": \"columns\",\n                    \"type\": \"column\",\n                    \"is_many\": true,\n                    \"relations\": [\n                        {\n                            \"field\": \"id\",\n                            \"reference\": \"table_id\"\n                        }\n                    ]\n                }\n            ],\n            \"schema\": \"private\"\n        },\n        {\n            \"id\": \"column\",\n            \"columns\": [\n                {\n                    \"id\": \"name\",\n                    \"name\": \"name\",\n                    \"type\": \"3\",\n                    \"dname\": \"Name\"\n                },\n                {\n                    \"id\": \"dname\",\n                    \"name\": \"dname\",\n                    \"type\": \"3\",\n                    \"dname\": \"Display Name\"\n                },\n                {\n                    \"id\": \"type\",\n                    \"name\": \"type\",\n                    \"type\": \"3\",\n                    \"required\": true,\n                    \"no_modify\": false,\n                    \"dname\": \"Type\"\n                },\n                {\n                    \"id\": \"required\",\n                    \"name\": \"required\",\n                    \"type\": \"4\",\n                    \"dname\": \"Required\"\n                },\n                {\n                    \"id\": \"is_many\",\n                    \"name\": \"is_many\",\n                    \"type\": \"4\",\n                    \"dname\": \"Is Many\"\n                },\n                {\n                    \"id\": \"no_modify\",\n                    \"name\": \"no_modify\",\n                    \"type\": \"4\",\n                    \"dname\": \"No Modify\"\n                },\n                {\n                    \"id\": \"format\",\n                    \"name\": \"format\",\n                    \"type\": \"3\",\n                    \"dname\": \"Format\"\n                },\n                {\n                    \"id\": \"table_id\",\n                    \"name\": \"table_id\",\n                    \"type\": \"3\",\n                    \"required\": true,\n                    \"dname\": \"Table ID\"\n                },\n                {\n                    \"id\": \"relations\",\n                    \"name\": \"relations\",\n                    \"type\": \"relation\",\n                    \"is_many\": true,\n                    \"relations\": [\n                        {\n                            \"field\": \"id\",\n                            \"reference\": \"column_id\"\n                        }\n                    ]\n                },\n                {\n                    \"id\": \"table\",\n                    \"name\": \"table\",\n                    \"type\": \"table\",\n                    \"relations\": [\n                        {\n                            \"field\": \"table_id\",\n                            \"reference\": \"id\"\n                        }\n                    ]\n                }\n            ],\n            \"schema\": \"private\"\n        }\n    ],\n    protected: [\n        {\n            \"id\": \"account\",\n            \"schema\": \"protected\",\n            \"columns\": [\n                {\n                    \"id\": \"name\",\n                    \"type\": \"3\"\n                },\n                {\n                    \"id\": \"type\",\n                    \"type\": \"3\"\n                },\n                {\n                    \"id\": \"status\",\n                    \"type\": \"3\"\n                }\n            ]\n        },\n        {\n            \"id\": \"department\",\n            \"schema\": \"protected\",\n            \"columns\": [\n                {\n                    \"id\": \"department_name\",\n                    \"type\": \"3\"\n                },\n                {\n                    \"id\": \"department_id\",\n                    \"type\": \"3\"\n                },\n                {\n                    \"id\": \"parent_id\",\n                    \"type\": \"3\"\n                },\n                {\n                    \"id\": \"appliedAt\",\n                    \"type\": \"5\"\n                },\n                {\n                    \"id\": \"department_user\",\n                    \"type\": \"department_user\",\n                    \"is_many\": true,\n                    \"relations\": [\n                        {\n                            \"field\": \"department_id\",\n                            \"reference\": \"department_id\"\n                        }\n                    ]\n                }\n            ]\n        },\n        {\n            \"id\": \"role\",\n            \"schema\": \"protected\",\n            \"columns\": [\n                {\n                    \"id\": \"name\",\n                    \"type\": \"name\"\n                },\n                {\n                    \"id\": \"schema_id\",\n                    \"type\": \"3\"\n                },\n                {\n                    \"id\": \"table_id\",\n                    \"type\": \"3\"\n                },\n                {\n                    \"id\": \"record_id\",\n                    \"type\": \"3\"\n                },\n                {\n                    \"id\": \"create\",\n                    \"name\": \"create\",\n                    \"type\": \"4\"\n                },\n                {\n                    \"id\": \"update\",\n                    \"name\": \"update\",\n                    \"type\": \"4\"\n                },\n                {\n                    \"id\": \"delete\",\n                    \"name\": \"delete\",\n                    \"type\": \"4\"\n                },\n                {\n                    \"id\": \"query\",\n                    \"name\": \"query\",\n                    \"type\": \"4\"\n                }\n            ]\n        },\n        {\n            \"id\": \"department_user\",\n            \"schema\": \"protected\",\n            \"columns\": [\n                {\n                    \"id\": \"department_id\",\n                    \"type\": \"3\"\n                },\n                {\n                    \"id\": \"user_id\",\n                    \"type\": \"3\"\n                },\n                {\n                    \"id\": \"role_id\",\n                    \"type\": \"3\"\n                },\n                {\n                    \"id\": \"role\",\n                    \"type\": \"role\",\n                    \"relations\": [\n                        {\n                            \"field\": \"role_id\",\n                            \"reference\": \"id\"\n                        }\n                    ]\n                }\n            ]\n        },\n        {\n            \"id\": \"department_hierarchy\",\n            \"schema\": \"protected\",\n            \"columns\": [\n                {\n                    \"id\": \"ancestor_id\",\n                    \"type\": \"3\"\n                },\n                {\n                    \"id\": \"descendant_id\",\n                    \"type\": \"3\"\n                },\n                {\n                    \"id\": \"depth\",\n                    \"type\": \"1\"\n                },\n                {\n                    \"id\": \"department_user\",\n                    \"type\": \"department_user\",\n                    \"is_many\": true,\n                    \"relations\": [\n                        {\n                            \"field\": \"ancestor_id\",\n                            \"reference\": \"department_id\"\n                        }\n                    ]\n                }\n            ]\n        }\n    ]\n};\n\nmsg.payload = Object.entries(msg.payload)\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 230,
        "y": 500,
        "wires": [
            [
                "96096491ed2e468c",
                "d906448b3abaf1fa"
            ]
        ]
    },
    {
        "id": "96096491ed2e468c",
        "type": "function",
        "z": "c23a997595de5280",
        "name": "Build Apolo",
        "func": "const { createId } = paralleldriveCuid2;\nif (msg.topic == \"request\") {\n    try {\n        let { schema, payload, context: contextValue } = msg.request;\n        node.status({\n            fill: \"blue\",\n            text: \"Processing: \" + contextValue.id\n        })\n        let requestParse = await context.get(\"getGraphQlServer\")({ schema, payload, options: { contextValue }});\n        if ( [\"error\", \"data\"].includes(requestParse.topic)) {\n            global.get(\"sendJobToQueue\")(contextValue.replyTo, contextValue.id, requestParse.payload, { jobId: contextValue.id });\n        //     node.status({\n        //     fill: \"blue\",\n        //     text: \"Res: \" + contextValue.id\n        // })\n        } else if (requestParse.topic == \"parse\") {\n            node.send(requestParse)\n        }\n    } catch (err) {\n        console.log(msg.request)\n        node.status({\n            fill: \"red\",\n            text: \"Processed error: \" + err.message\n        })\n    }\n} else if ( msg.topic == \"configTables\") {\n    msg.payload.forEach( async ([schema, tables]) => {\n        console.log(schema)\n        await context.get(\"createGraphqlServer\")(schema, tables);\n    });\n    node.send(msg);\n}\n\nreturn null;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "const { EventEmitter } = events;\nconst { ApolloServer } = apolloServer;\nconst { createId } = paralleldriveCuid2;\nconst bcrypt = {};\nconst soc = async ( schema, func ) => {\n   let newObject = await func({ \n    query: async (queryString, variables = {}, returnFunc) => {\n      return await flow.get('_emit')('queryNow', { queryString, variables })\n    }\n   });\n};\nconst jwt = {};\n\nconst emitter = new EventEmitter();\nemitter.setMaxListeners(0);\nconst AsyncFunction = (async function () { }).constructor;\n\nconst OperationMap = new Map([\n    [\"ne\", \"not\"],\n    [\"eq\", \"equals\"],\n    [\"gt\", \"gt\"],\n    [\"ge\", \"gte\"],\n    [\"lt\", \"lt\"],\n    [\"le\", \"lte\"],\n    [\"in\", \"in\"],\n    [\"nin\", \"notIn\"],\n    [\"ct\", \"contains\"],\n    [\"sw\", \"startsWith\"],\n    [\"ew\", \"endsWith\"],\n    [\"and\", \"and\"],\n    [\"not\", \"not\"],\n    [\"or\", \"or\"],\n]);\n\nconst ArgsDefaultMap = new Map([\n    [\"where\", {}]\n]);\n\nvar setterMap = new Map();\nconst defind = \"let [bcrypt, soc, jwt, $] = arguments;\";\n\nconst parseArguments = function (args, variables) {\n    function parseVariable(value) {\n        if (value && typeof value == \"object\") {\n          if (Object.prototype.toString.call(value) === '[object Object]') {\n                return Object.fromEntries(Object.entries(value).map(([key, val]) => [OperationMap.get(key) || key, parseVariable(val)]));\n            } else if (Object.prototype.toString.call(value) === '[object Array]') {\n                return value.map((val) => parseVariable(val));\n            }\n        } else {\n            return value;\n        }\n    }\n\n    function parseValue(value) {\n        if (value.kind == \"Variable\") {\n            return parseVariable(variables[value.name.value]);\n        }\n    };\n    let re = Object.fromEntries(args.map((arg) => ([arg.name.value, parseValue(arg.value) || ArgsDefaultMap.get(arg.name.value)])));\n    return re;\n};\n\nclass Build_graphQlServer {\n    constructor({ tables, path }) {\n        this.path = path;\n        this.tables = tables;\n        this.typeDefType = new Map([\n            [\"0\", \"ID\"],\n            [\"1\", \"Int\"],\n            [\"2\", \"Float\"],\n            [\"3\", \"String\"],\n            [\"4\", \"Boolean\"],\n            [\"5\", \"Date\"],\n            [\"6\", \"Json\"],\n        ]);\n\n        this.sendAndListenQueue;\n        this.initTypeDefs = `\n                scalar Date\n                scalar Json\n                scalar asc\n                scalar desc\n        \n                input ModelIntWhereInput {\n                  _neq: Int\n                  _eq: Int\n                  _lte: Int\n                  _lt: Int\n                  _gte: Int\n                  _gt: Int\n                  _in: [Int]\n                  _nin: [Int]\n                  _is_null: Boolean\n                  neq: Int\n                  eq: Int\n                  equals: Int\n                  lte: Int\n                  lt: Int\n                  gte: Int\n                  gt: Int\n                  in: [Int]\n                  notIn: [Int]\n                }\n        \n                input ModelFloatWhereInput {\n                  _neq: Float\n                  _eq: Float\n                  _lte: Float\n                  _lt: Float\n                  _gte: Float\n                  _gt: Float\n                  _in: [Float]\n                  _nin: [Float]\n                  _is_null: Boolean\n                  neq: Float\n                  eq: Float\n                  equals: Float\n                  lte: Float\n                  lt: Float\n                  gte: Float\n                  gt: Float\n                  in: [Float]\n                  notIn: [Float]\n                }\n        \n                input ModelStringWhereInput {\n                  _neq: String\n                  _eq: String\n                  _like: String\n                  _ilike: String\n                  _regex: String\n                  _iregex: String\n                  _similar: String\n                  _in: [String]\n                  _nin: [String]\n                  _is_null: Boolean\n                  neq: String\n                  eq: String\n                  equals: String\n                  like: String\n                  iLike: String\n                  regex: String\n                  iRegex: String\n                  similar: String\n                  in: [String]\n                  notEquals: String\n                  notLike: String\n                  notILike: String\n                  notRegex: String\n                  notIRegex: String\n                  notSimilar: String\n                  notIn: [String]\n                  isNull: Boolean\n                }\n        \n                input ModelBooleanWhereInput {\n                  _not: Boolean\n                  _eq: Boolean\n                  _in: [Boolean]\n                  _nin: [Boolean]\n                  _is_null: Boolean\n                  not: Boolean\n                  equals: Boolean\n                  in: [Boolean]\n                  notIn: [Boolean]\n                  isNull: Boolean\n                }\n        \n                input ModelDateWhereInput {\n                  _neq: Date\n                  _eq: Date\n                  _lte: Date\n                  _lt: Date\n                  _gte: Date\n                  _gt: Date\n                  _in: [Date]\n                  _nin: [Date]\n                  _is_null: Boolean\n                  neq: Date\n                  eq: Date\n                  equals: Date\n                  lte: Date\n                  lt: Date\n                  gte: Date\n                  gt: Date\n                  in: [Date]\n                  notIn: [Date]\n                  isNull: Boolean\n                }\n      \n                input ModelJsonCastInput {\n                  String: ModelStringWhereInput\n                }\n      \n                input ModelJsonWhereInput {\n                  _cast: ModelJsonCastInput\n                  _eq: Json\n                  cast: ModelJsonCastInput\n                  equals: Json\n                  hasKey: String\n                }\n        \n                input ModelListStringWhereInput {\n                  _contains: String\n                  _eq: [String]\n                  _has_keys_all: [String]                                                               \n                  _has_keys_any: [String]\n                  _is_null: Boolean\n                  has: String\n                  equals: [String]\n                  hasEvery: [String]                                                               \n                  hasSome: [String]\n                  isEmpty: Boolean\n                  isSet: Boolean\n                }\n      \n                input ModelListIntWhereInput {\n                  _contains: Int\n                  _eq: [Int]\n                  _has_keys_all: [Int]                                                               \n                  _has_keys_any: [Int]\n                  _is_null: Boolean\n                  has: Int\n                  hasEvery: [Int]                                                               \n                  hasSome: [Int]\n                  isEmpty: Boolean\n                }\n      \n                input ModelListFloatWhereInput {\n                  _contains: Float\n                  _eq: [Float]\n                  _has_keys_all: [Float]                                                               \n                  _has_keys_any: [Float]\n                  _is_null: Boolean\n                  has: Float\n                  equals: [Float]\n                  hasEvery: [Float]                                                               \n                  hasSome: [Float]\n                  isEmpty: Boolean\n                  isSet: Boolean\n                }\n      \n                input ModelListDateWhereInput {\n                  _contains: Date\n                  _eq: [Date]\n                  _has_keys_all: [Date]                                                               \n                  _has_keys_any: [Date]\n                  _is_null: Boolean\n                  has: Date\n                  equals: [Date]\n                  hasEvery: [Date]                                                               \n                  hasSome: [Date]\n                  isEmpty: Boolean\n                  isSet: Boolean\n                }\n      \n                enum ModelOrderByInput {\n                  asc\n                  desc\n                }\n            `;\n        this.tables = new Map(tables.map((x) => [x.id, x]));\n    }\n\n    setQueue(func) {\n        this.sendAndListenQueue = func;\n    }\n\n    generateTypeDefs() {\n        return [\n            this.initTypeDefs,\n            ...[...this.tables.values()].map(({ id, schema, columns, column }) => {\n                return column\n                    ? `\n            type ${id} {\n              id: String\n              createdAt: Date\n              updatedAt: Date\n              ${columns.map(({ id, type, required, is_many }) => `${id}: ${is_many ? \"[\" : \"\"}${this.typeDefType.has(type) ? this.typeDefType.get(type) : type}${is_many ? \"]\" : \"\"}${required ? \"!\" : \"\"}`).join(\"\\n\\t\")}\n          }`\n                    : `\n        type ${id} {\n            id: String\n            createdAt: Date\n            updatedAt: Date\n            ${columns\n                        .filter(({ relations, type }) => [...(relations || [])].length == 0 && this.typeDefType.get(type))\n                        .map(({ id, type, required, is_many }) => `${id}: ${is_many ? \"[\" : \"\"}${this.typeDefType.get(type)}${is_many ? \"]\" : \"\"}${required ? \"!\" : \"\"}`)\n                        .join(\"\\n\\t\")}\n            ${columns\n                        .filter(({ relations, type }) => (relations?.length && this.tables.has(type)))\n                        .map(({ id, type, required, is_many }) => `list_${type} (where: Model${type}WhereInput, distinctOn: [Model${type}ColumnInput], limit: Int, offset: Int, orderBy: Model${type}OrderByInput): [${type}]`)\n                        .join(\"\\n\\t\")}\n        }\n  \n        ${(() => {\n                        let col_number_ids = columns.filter(({ type }) => [\"1\", \"2\"].includes(type)).map(x => x.id);\n                        return col_number_ids > 0 ?\n                            `type ${id}_is_number {\n            ${col_number_ids.join(\"\\n\\t\")}\n          }\n          \n          type ${id}_aggregate_object {\n            count: Int\n            ${[\"sum\", \"avg\", \"stddev\", \"stddev_pop\", \"stddev_samp\", \"var_pop\", \"var_samp\", \"variance\"].map(operation => `${operation}: type ${id}_is_number`).join(\"\\n\\t\")}\n          }\n  \n          ` : `\n          type ${id}_aggregate_object {\n            count: Int\n          }\n          `\n\n                    })()}\n  \n        type ${id}_aggregate {\n          aggregate: ${id}_aggregate_object\n          nodes: [${id}]\n        }\n  \n        input Model${id}WhereInput {\n            id: ModelStringWhereInput\n            createdAt: ModelDateWhereInput\n            updatedAt: ModelDateWhereInput\n            and: [Model${id}WhereInput]\n            or: [Model${id}WhereInput]\n            not: Model${id}WhereInput\n            ${columns\n                        .filter(({ relations, type }) => [...(relations || [])].length == 0 && this.typeDefType.get(type))\n                        .map(({ id, type, required, is_many }) => `${id}: Model${this.typeDefType.get(type)}WhereInput`)\n                        .join(\"\\n\\t\")}\n            ${columns\n                        .filter(({ relations, type }) => (relations?.length && this.tables.has(type)))\n                        .map(({ id, type, required, is_many }) => `list_${type}: Model${type}WhereInput`)\n                        .join(\"\\n\\t\")}\n        }\n  \n        input Model${id}OrderByInput {\n          id: ModelOrderByInput\n          createdAt: ModelOrderByInput\n          updatedAt: ModelOrderByInput\n          ${columns\n                        .filter(({ relations, type }) => [...(relations || [])].length == 0 && this.typeDefType.get(type))\n                        .map(({ id, type, required, is_many }) => `${id}: ModelOrderByInput`)\n                        .join(\"\\n\\t\")}\n        }\n  \n        enum Model${id}ColumnInput {\n          id\n          createdAt\n          updatedAt\n          ${columns\n                        .filter(({ relations, type }) => [...(relations || [])].length == 0 && this.typeDefType.get(type))\n                        .map(({ id, type, required, is_many }) => `${id}`)\n                        .join(\"\\n\\t\")}\n        }\n  \n        ${(() => {\n                        let _columns = columns.filter(({ relations, type }) => [...(relations || [])].length == 0 && this.typeDefType.get(type));\n                        _columns = _columns.map(({ id: column_id, type, required, is_many }) => `${column_id}: ${is_many ? \"[\" : \"\"}${this.typeDefType.has(type) ? this.typeDefType.get(type) : type}${is_many ? \"]\" : \"\"}${(required && !id.endsWith(\"history\")) ? \"!\" : \"\"}`);\n\n                        return `input Model${id}CreateInput {\n            ${[\"version: String\", ..._columns].join(\"\\n\\t\")}\n          }`;\n                    })()}\n  \n        ${(() => {\n                        let _columns = columns.filter(({ relations, type, no_modify }) => !no_modify && [...(relations || [])].length == 0 && this.typeDefType.get(type));\n                        _columns = _columns.map(({ id, type, required, is_many }) => `${id}: ${is_many ? \"[\" : \"\"}${this.typeDefType.has(type) ? this.typeDefType.get(type) : type}${is_many ? \"]\" : \"\"}`);\n                        return `input Model${id}UpdateInput {\n           ${[\"version: String\", ..._columns].join(\"\\n\\t\")} \n          }`;\n                    })()}\n        \n        ${(id.endsWith(\"_history\") || (schema !== this.path)) ? '' : `type Query {\n          get_${id} (id: ID!): ${id}!\n          list_${id} (where: Model${id}WhereInput, distinctOn: [Model${id}ColumnInput], limit: Int, offset: Int, orderBy: Model${id}OrderByInput): [${id}]!\n          aggregate_${id} (where: Model${id}WhereInput): ${id}_aggregate!\n        }\n    \n        type Mutation {\n          create_${id} (input: Model${id}CreateInput!): ${id}!\n          update_${id} (input: Model${id}UpdateInput!, id: ID!): ${id}!\n          delete_${id} (id: ID!): ${id}!\n        }\n  \n        type Subscription {\n          get_${id} (id: ID!): ${id}!\n          list_${id} (where: Model${id}WhereInput, distinctOn: [Model${id}ColumnInput], limit: Int, offset: Int, orderBy: Model${id}OrderByInput): [${id}]!\n        }`}\n        `;\n            }),\n        ].join(\"\\n\");\n    }\n\n    convertGraph = function (field, table, args = {}, variables = {}, headers, child = false) {\n        return {\n            ...(child ? {} : { schema: table.schema, headers }),\n            schema: table.schema,\n            target: [field.alias ? field.alias.value : field.name.value, (child && false) ? field.name.value : table.id],\n            variables: parseArguments(field.arguments, variables),\n            fields: field.selectionSet?.selections.filter((_field) => !_field.selectionSet).map((_field) => (_field.alias ? [_field.alias.value, _field.name.value] : [_field.name.value])),\n            links: field.selectionSet?.selections.filter((_field) => _field.selectionSet).map((_field) => this.convertGraph(_field, this.tables.get((table.columns.filter((col) => `list_${col.type}` == _field.name.value)[0] || { type: _field.name.value }).type), args, variables, headers, true)),\n        };\n    };\n\n    generateResolves() {\n        const tables = this.tables;\n        let all_action = [];\n        [...this.tables]\n            .map(([key, val]) => val)\n            .filter(({ id, schema, column }) => !column && !id.endsWith(\"_history\") && (schema === this.path))\n            .forEach(({ id, columns }) => {\n                all_action = [\n                    ...all_action,\n                    ...[\n                        [\"query\", \"get\"],\n                        [\"query\", \"list\"],\n                        [\"query\", \"aggregate\"],\n                        [\"mutation\", \"create\"],\n                        [\"mutation\", \"update\"],\n                        [\"mutation\", \"delete\"],\n                        [\"subscription\", \"get\"],\n                        [\"subscription\", \"list\"],\n                    ].map(([mode, type]) => [\n                        mode,\n                        type + \"_\" + id,\n                        async (parentValue, args, context, info) => {\n                            let query = this.convertGraph(info.fieldNodes[0], this.tables.get(id), args, info[\"variableValues\"], context.headers, false);\n                            return await this.sendAndListenQueue(mode, type, query, context);\n                        },\n                    ]),\n                ];\n            });\n\n        return {\n            Query: Object.fromEntries(all_action.filter(([mode, name, func]) => mode == \"query\").map(([type, name, func]) => [name, func])),\n            Mutation: Object.fromEntries(all_action.filter(([mode, name, func]) => mode == \"mutation\").map(([type, name, func]) => [name, func])), Subscription: Object.fromEntries(all_action.filter(([mode, name, func]) => mode == \"subscription\").map(([type, name, func]) => [name, func])),\n        };\n    }\n}\n\nvar graphQlServerContainer = {};\nvar graphQlServerContainerLoading = {};\nvar completegraphQlServerContainer = async function (schema) {\n    emitter.emit(schema, { error: false })\n}\n\nlet createGraphqlServer = async (schema, tables) => {\n  node.status({\n    fill: \"red\",\n    shape: \"ring\",\n    text: \"Start Graphql Server: \" + schema\n  })\n  let graphQlServer = new Build_graphQlServer({\n    path: schema,\n    tables\n  });\n\n  const queue = async (mode, action, data, context) => {\n    return new Promise((resolve, reject) => {\n      emitter.emit(context.headers['transaction-id'], {\n        mode, action, objectQuery: data, context\n      });\n      reject(\"success\")\n      // throw new Error({ message: \"success\" });\n    })\n  };\n  graphQlServer.setQueue(queue);\n  const apolloServer = new ApolloServer({\n    typeDefs: graphQlServer.generateTypeDefs(),\n    resolvers: graphQlServer.generateResolves(),\n    introspection: true,\n    cache: \"bounded\",\n  });\n  await apolloServer.start();\n  graphQlServerContainer[schema] = apolloServer;\n  completegraphQlServerContainer(schema);\n  node.status({\n    fill: \"green\",\n    shape: \"ring\",\n    text: \"End Graphql Server: \" + schema\n  });\n\n  // tables.forEach( async ({ id, setter }) => {\n  //   if (setter) {\n  //     setterMap.set(id, await new AsyncFunction( defind + setter).bind({}, { bcrypt, soc, jwt })())\n  //   } else {\n  //     setterMap.set(id, () => {})\n  //   }\n  // })\n}\n\n\n\nconst getGraphqlServer = async ({ schema, payload, options }) => {\n  return await new Promise(async (resolve, reject) => {\n    try {\n      if (!graphQlServerContainer[schema]) {\n        resolve({\n          topic: \"error\",\n          payload: {\n            type: \"error\",\n            payload: {\n              errors: [{\n                message: \"Not found schema: \" + schema\n              }]\n            }\n          }\n        });\n        return\n      }\n      let transactionId = createId();\n      options.contextValue.headers['transaction-id'] = transactionId;\n      emitter.once(transactionId, res => {\n        // let new_res = await setterMap.get(res.target[1]).bind(res)();\n        resolve({\n          topic: \"parse\",\n          payload: res\n        })\n      });\n      let result = await graphQlServerContainer[schema].executeOperation(payload, options).catch(err => {\n        return {\n          body: {\n            singleResult: {\n              errors: true,\n              payload: err.message\n            }\n          }\n        };\n      });\n      let resData = result?.body?.singleResult || {};\n      if (resData?.errors) {\n        resolve({\n          topic: \"error\",\n          payload: { type: 'error', payload: resData }\n        })\n      } else {\n        resolve({\n          topic: \"data\",\n          payload: { type: 'data', payload: resData }\n        })\n      };\n      return null\n    } catch (err) {\n      resolve({\n        topic: \"error\",\n        payload: {\n          type: 'error', payload: {\n            errors: [{\n              message: err.message\n            }]\n          }\n        }\n      })\n    }\n  })\n}\n\ncontext.set(\"createGraphqlServer\", createGraphqlServer)\ncontext.set(\"getGraphQlServer\", getGraphqlServer);\nflow.set(\"getGraphQlServer\", getGraphqlServer)\nflow.set(\"setter\", (table_id) => {\n  return setterMap.get(table_id)\n});\n\n// $local.Build_graphQlServer = Build_graphQlServer;\n// $local.graphQlServerContainer = {};\n// $local.graphQlServerContainerLoading = {};\n// $local.createWaittinggraphQlServerContainer = async function (schema) {\n//     return await new Promise((resolve, reject) => {\n//         emitter.once(schema, () => { resolve(null) })\n//     })\n// };\n\n// $local.completegraphQlServerContainer = async function (schema) {\n//     emitter.emit(schema, { error: false })\n// }\n\n// flow.get('_on')('queryNow', async (schema , { queryString, variables }, options) => {\n//   let requestParseNow = getGraphqlServer({ schema, payload: { query: queryString, variables }, options });\n//   if ([\"error\", \"data\"].includes(requestParseNow.topic)) {\n//     return requestParseNow\n//   } else if (requestParseNow.topic == \"parse\") {\n//     return new Promise( (resolve, reject) => {\n//       requestParseNow[\"resolveNow\"] = resolve;\n//       node.send(requestParseNow)\n//     })\n//   }\n\n// })\nreturn null;",
        "finalize": "",
        "libs": [
            {
                "var": "events",
                "module": "events"
            },
            {
                "var": "apolloServer",
                "module": "@apollo/server"
            },
            {
                "var": "paralleldriveCuid2",
                "module": "@paralleldrive/cuid2"
            }
        ],
        "x": 650,
        "y": 800,
        "wires": [
            [
                "628cf31e70219aad"
            ]
        ]
    },
    {
        "id": "8364f1a68ee53433",
        "type": "function",
        "z": "c23a997595de5280",
        "name": "Query Worker",
        "func": "context.get('init')()",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "const send = (job) => {\n    node.send({\n        topic: \"request\",\n        request: job.data\n    })\n}\nconst init = async () => {\n    node.status({ fill: \"blue\", shape: \"ring\", text: \"Starting\" });\n    global.get(\"setWorker\")(\"query\", (job) => {\n        let mes = `Process job: ${job.id}`\n        node.status({ fill: \"green\", shape: \"ring\", text: mes });\n        console.log(mes)\n        send(job)\n    }, { concurrency: 100 })\n}\n\ncontext.set(\"init\", init);",
        "finalize": "",
        "libs": [],
        "x": 320,
        "y": 380,
        "wires": [
            [
                "96096491ed2e468c"
            ]
        ]
    },
    {
        "id": "8b4ef052d350767e",
        "type": "function",
        "z": "c23a997595de5280",
        "name": "Convert Query To Hasura",
        "func": "let { mode, action, objectQuery, context: contextValue, resolveNow } = msg.payload;\ntry {\n    node.send([{\n        topic: \"parse\",\n        payload: await context.get(\"queryNow\")( contextValue.id, action, objectQuery, true),\n        type: \"start\",\n        objectQuery,\n        mode,\n        action,\n        contextValue,\n        resolveNow\n    }])\n    node.status({\n        fill: \"green\",\n        shape: \"ring\",\n        text: contextValue.id\n    })\n} catch (err) {\n    console.log(err.message)\n}\nreturn null;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "const { createId } = paralleldriveCuid2;\n\nconst filterPrismaToHasuraInWhere = new Map([\n     [\"neq\", [\"_neq\"]],\n     [\"eq\", [\"_eq\"]],\n     [\"equals\", [\"_eq\"]],\n     [\"lte\", [\"[_lte\"]],\n     [\"lt\", [\"_lt\"]],\n     [\"gte\", [\"_gte\"]],\n     [\"gt\", [\"_gt\"]],\n     [\"in\", [\"_in\"]],\n     [\"notIn\", [\"_nin\"]],\n     [\"like\", [\"_like\"]],\n     [\"iLike\", [\"_ilike\"]],\n     [\"regex\", [\"_regex\"]],\n     [\"iRegex\", [\"_iregex\"]],\n     [\"hasKey\", [\"_has_key\"]],\n     [\"isNull\", [\"_is_null\"]],\n ]);\n\nconst filterPrismaToHasura = new Map([\n       [\"neq\", [\"_neq\"]],\n       [\"eq\", [\"_eq\"]],\n       [\"equals\", [\"_eq\"]],\n       [\"lte\", [\"[_lte\"]],\n       [\"lt\", [\"_lt\"]],\n       [\"gte\", [\"_gte\"]],\n       [\"gt\", [\"_gt\"]],\n       [\"in\", [\"_in\"]],\n       [\"notIn\", [\"_nin\"]],\n       [\"like\", [\"_like\"]],\n       [\"iLike\", [\"_ilike\"]],\n       [\"regex\", [\"_regex\"]],\n       [\"iRegex\", [\"_iregex\"]],\n       [\"and\", [\"_and\"]],\n       [\"or\", [\"_or\"]],\n       [\"not\", [\"_not\"]],\n       [\"distinctOn\", [\"distinct_on\"]],\n       [\"orderBy\", [\"order_by\"]],\n       [\"hasKey\", [\"_has_key\"]],\n       [\"cast\", [\"_cast\"]],\n       [\"String\", [\"String\"]],\n       [\"path\", [\"path\"]],\n   ]);\n\nconst generatedHasuraVariables = (objectQuery, type = undefined, zone = '', level = '') => {\n    // objectQuery.variables.where = { and: [objectQuery.variables.where || {}, { deletedAt: { isNull: true } }] }\n    objectQuery.variables.where = { and: [objectQuery.variables.where || {}] }\n    let generatedHasuraVariablesZone = (variables, type = undefined) => {\n        return Object.fromEntries(Object.entries(variables).map(([key, val]) => {\n            let test_key = filterPrismaToHasuraInWhere.get(key);\n            if (test_key) {\n                return [test_key, val]\n            } else {\n                let _type = type || key;\n                let new_key = [...filterPrismaToHasura.get(key) || [key]][0];\n                if (val && [\"and\", \"or\", \"not\"].includes(key) && Object.prototype.toString.call(val) === '[object Array]') {\n                    return [new_key, val.map(_val => generatedHasuraVariablesZone(_val, _type))]\n                } else if (val && !filterPrismaToHasuraInWhere.has(key) && Object.prototype.toString.call(val) === '[object Object]') {\n                    if (new_key.startsWith(\"list\")) {\n                        return [new_key, generatedHasuraVariablesZone({ and: [{ deletedAt: { isNull: true } }, val] }, _type)]\n                    } else {\n                        return [new_key, generatedHasuraVariablesZone(val, _type)]\n                    }\n                } else {\n                    return [new_key, val]\n                }\n            }\n        }))\n    }\n    return Object.fromEntries([...Object.entries(generatedHasuraVariablesZone(objectQuery.variables)).map(([key, val]) => [`${key}_${zone}_${level}`, val]),\n    ...objectQuery.links.map((childQuery, childQueryIndex) => Object.entries(generatedHasuraVariables(childQuery, undefined, `${zone}${level}`, childQueryIndex))).flat()\n    ])\n}\n\nconst target_begin = {\n    get: ``,\n    list: ``,\n    aggregate: ``,\n    create: 'insert_',\n    update: \"update_\"\n}\n\nconst target_end = {\n    get: ``,\n    list: ``,\n    aggregate: `_aggregate`,\n    create: '_one',\n    update: \"_by_pk\"\n}\n\nconst generatedHasuraQuery = (type, action, objectQuery, root = true, zone = '', level = '') => {\n    console.log(type, action, objectQuery.target, objectQuery.schema)\n    return `${([\"socket\", \"subscription\"].includes(type)) ? `${[...objectQuery.target].shift()}:` : (root ? \"data:\" : \"\")}${objectQuery.schema ? `${root ? `${objectQuery.schema}_` : \"list_\"}${objectQuery.target.slice(-1)}${target_end[action]}` : objectQuery.target.slice(-1)[0]}\n    ${Object.keys(objectQuery.variables).length > 0 ? `(${(() => {\n            let trans_variables = Object.keys(objectQuery.variables).map(k => (filterPrismaToHasura.get(k) || [k])[0]);\n            return [\n                [\"where\", `$where_${zone}_${level}`],\n                [\"order_by\", `$order_by_${zone}_${level}`],\n                [\"distinct_on\", `$distinct_on_${zone}_${level}`],\n                [\"limit\", `$limit_${zone}_${level}`],\n                [\"offset\", `$offset_${zone}_${level}`],\n            ].filter(([key, val]) => trans_variables.includes(key)).map((x) => x.join(\": \")).join(\", \")\n\n        })()\n            })` : \"\"} {\n            ${objectQuery.fields.map((x) => `${(x.length > 1 && [\"socket\", \"subscription\"].includes(type)) ? `${x.slice(0, 1)[0]}:` : \"\"}${x.slice(-1)[0]}`).join(\"\\n\")}\n            ${objectQuery.links.map((x, linkIndex) => generatedHasuraQuery(type, action, x, false, `${zone}${level}`, linkIndex))}\n        }`;\n}\n\nconst generateHasuraVariablesType = (objectQuery, zone = '', level = '') => {\n    let table = `${objectQuery.schema}_${[...objectQuery.target].pop().replace(\"list_\", \"\")}`\n    let keys = Object.keys(objectQuery.variables).map(k => (filterPrismaToHasura.get(k) || [k])[0]);\n    let tt = [...[\n        [\"where\", `${table}_bool_exp`],\n        [\"order_by\", `[${table}_order_by!]`],\n        [\"distinct_on\", `[${table}_select_column!]`],\n        [\"limit\", `Int`],\n        [\"offset\", `Int`],\n    ].filter(([key, val]) => keys.includes(key)).map(([key, val]) => `$${key}_${zone}_${level}: ${val}`),\n    ...objectQuery.links.map((childQuery, childQueryIndex) => generateHasuraVariablesType(childQuery, `${zone}${level}`, childQueryIndex))\n    ]\n    return tt.filter(x => x).join(\",\")\n}\n\nconst generateHasuraObject = (id, mode, action, objectQuery, root = true) => {\n    if (objectQuery.variables.id) {\n        objectQuery.variables[\"where\"] = objectQuery.variables[\"where\"] || {};\n        objectQuery.variables[\"where\"][\"id\"] = { _eq: objectQuery.variables.id };\n        delete objectQuery.variables.id;\n    }\n\n    let table = `${objectQuery.schema}_${objectQuery.target.slice(-1)[0]}`\n    let _variables = generatedHasuraVariables(objectQuery);\n    let _variablesType = generateHasuraVariablesType(objectQuery);\n    let _query = generatedHasuraQuery(mode, action, objectQuery);\n\n    return ({\n        query: `${mode === \"subscription\" ? mode : \"query\"} ${id}${_variablesType ? ` (${_variablesType}) ` : \"\"}{ ${_query} }`,\n        variables: _variables\n    })\n}\n\nconst applyRole = async (action, objectQuery) => {\n    objectQuery.user = {};\n    if (objectQuery.headers['authorization'] && objectQuery.headers['authorization']['startsWith'](\"Bearer \")) {\n        let token = objectQuery.headers['authorization'].slice(7)\n        let payload = jwt.verify(token, await jwt.getPrivateKey(), { algorithm: \"HS512\" })\n        objectQuery.user['id'] = payload.userId;\n    }\n\n    objectQuery.links.map(childObjectQuery => applyRole(action, Object.assign(childObjectQuery, { headers: objectQuery.headers })))\n    // if ([\"get\", \"list\"].includes(action)) {\n    //     if (objectQuery.variables.id) {\n    //         objectQuery.variables[\"where\"] = objectQuery.variables[\"where\"] || {};\n    //         objectQuery.variables[\"where\"][\"id\"] = { _eq: objectQuery.variables.id };\n    //         delete objectQuery.variables.id;\n    //     }\n    //     let getter = getters.get(objectQuery.target[1])\n    //     if (getter) {\n    //         await getter.bind(objectQuery)()\n    //     }\n    // } else if ([\"create\", \"update\"].includes(action)) {\n    //     let setter = setters.get(objectQuery.target[1]);\n    //     if (setter) {\n    //         await setter.bind(objectQuery)()\n    //     }\n    // }\n    return objectQuery\n}\n\nconst queryNow = async (id, action, objectQuery, socket = false, callback = () => { }) => {\n    id = id || createId()\n    objectQuery = await applyRole(action, objectQuery) || objectQuery;\n    let _query2 = generateHasuraObject(id, (socket || true) ? \"subscription\" : \"query\", action, objectQuery);\n    return _query2\n    // await sendData(id, { operationName: id, ..._query2 }, \"start\");\n    // return await new Promise((resolve, reject) => {\n    //     emitter.once(id, async (_preDeleteRecord) => {\n    //         resolve(_preDeleteRecord)\n    //     })\n    // })\n};\ncontext.set(\"queryNow\", queryNow)",
        "finalize": "",
        "libs": [
            {
                "var": "paralleldriveCuid2",
                "module": "@paralleldrive/cuid2"
            },
            {
                "var": "jwt",
                "module": "jsonwebtoken"
            }
        ],
        "x": 370,
        "y": 1140,
        "wires": [
            [
                "5bdc419d149273cc"
            ]
        ]
    },
    {
        "id": "5bdc419d149273cc",
        "type": "function",
        "z": "c23a997595de5280",
        "name": "hasura Worker",
        "func": "if ( msg.topic == \"parse\") {\n    let { payload, type, contextValue, mode, action, resolveNow } = msg;\n    console.log(msg)\n    context.get(\"sendQuery\")(msg)\n}",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "var wsApp;\nvar wsAppConnected = false;\nvar emitter = new events.EventEmitter();\nemitter.setMaxListeners(0);\n\nlet workerId = paralleldriveCuid2.createId();\n// await global.get(\"getQueue\")(\"worker\"); \n\nlet connectSocket = async () => {\n    let hasuraURL = new url.URL(env.get(\"HASURA_URL\"));\n    // Convert Ws Query\n    hasuraURL.protocol = \"ws:\";\n    hasuraURL.pathname = \"/v1/graphql\";\n    console.log(`Connecting Hasura: ${hasuraURL.href}`);\n    wsApp = new WebSocket(hasuraURL.href, [\"graphql-ws\"]);\n    wsApp.on(\"open\", async () => {\n        console.log(`Connect Hasura successfully: ${hasuraURL.href}`);\n        await wsApp.send(JSON.stringify({ type: \"connection_init\", \n        payload: { \n            headers: { \n                \"content-type\": \"application/json\",\n                \"x-hasura-admin-secret\": \"anh08091998t@HASURA\"\n                }, lazy: true } }));\n    });\n\n    wsApp.on(\"message\", async (msg) => {\n        const { id, type, payload } = JSON.parse(msg.toString());\n        console.log(\"message\", id, type, payload?.errors, payload?.data);\n        node.status({fill:\"red\",shape:\"ring\",text: JSON.stringify(payload)});\n        if (id) {\n            let has_listener = await emitter.emit(id, {\n                type,\n                payload\n            });\n            if (!has_listener) {\n                emitter.emit(`stop-${id}`, null)\n            }\n        } else if (type === \"connection_ack\") {\n            wsAppConnected = true;\n            emitter.emit(\"connect\", true);\n        }\n    });\n\n\n    wsApp.on(\"error\", (err) => {\n        console.log(\"Connect Hasura failed!\");\n    });\n\n    wsApp.on(\"close\", () => {\n        console.log(\"Connect Hasura Socket closed!\");\n        console.log(`Try reconnect to Hasura after: 1000ms`);\n        if (this.state !== \"close\") {\n            setTimeout(connectSocket, 1000)\n        }\n    });\n};\n\nconnectSocket();\n\ncontext.set(\"sendQuery\", async ({ payload, type, mode, action, contextValue, objectQuery, resolveNow}) => {\n    try {\n        await wsApp.send(JSON.stringify({ id: contextValue.id, payload, type }));\n        emitter.on(contextValue.id, async (returnValue) => {\n            if ([\"get\"].includes(action) && returnValue.payload?.data) {\n                returnValue.payload.data[objectQuery.target[0]] = returnValue.payload.data[objectQuery.target[0]][0]\n            };\n            if (resolveNow) {\n                resolveNow(returnValue)\n            } else {\n                if (contextValue.replyTo) {\n                    node.send({\n                        topic: \"reply\",\n                        returnValue,\n                        replyTo: contextValue.replyTo,\n                        id: contextValue.id\n                    });\n                };\n            }\n            if ( ['error', 'complete'].includes(returnValue.type)) {\n                emitter.removeAllListeners(contextValue.id)\n            }\n        })\n    } catch (err) {\n        console.log(err)\n    }\n})",
        "finalize": "",
        "libs": [
            {
                "var": "events",
                "module": "events"
            },
            {
                "var": "WebSocket",
                "module": "ws"
            },
            {
                "var": "paralleldriveCuid2",
                "module": "@paralleldrive/cuid2"
            },
            {
                "var": "url",
                "module": "url"
            }
        ],
        "x": 700,
        "y": 1200,
        "wires": [
            [
                "455564d6912289d5"
            ]
        ]
    },
    {
        "id": "455564d6912289d5",
        "type": "function",
        "z": "c23a997595de5280",
        "name": "send Response To ReplyTo Queue",
        "func": "// flow.get(\"sendJobToQueue\")( msg.replyTo, msg.id, msg.returnValue, { jobId: msg.id})\nglobal.get(\"sendJobToQueue\")(msg.replyTo, msg.id, msg.returnValue, { jobId: msg.id });\nlet status = `job:${msg.id} => worker:${msg.replyTo} `\nnode.status({fill:\"red\",shape:\"ring\",text:status});\nconsole.log(status)\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "// // Code added here will be run once\n// // whenever the node is started.\n// const { Queue, QueueEvents } = bullmq;\n// const IORedis = ioredis;\n\n// const connection = new IORedis(env.get(\"REDIS_URL\"), { maxRetriesPerRequest: null });\n// const AsyncFunction = (async function () { }).constructor;\n\n// var queues = {};\n// var eventQueues = {};\n\n// var newQueue;\n// var newQueueEvents;\n\n// context.set(\"createNewQueue\", async (name) => {\n//     newQueue = await new Queue(name, { connection });\n//     newQueueEvents = await new QueueEvents(name, { connection })\n//     await context.set(\"addJob\", async (jobName, jobData) => {\n//         var job = await newQueue.add(jobName, jobData);\n//         const result = await job.waitUntilFinished(newQueueEvents);\n//         return result\n//     })\n// });\n\n// context.set(\"sendJobToQueue\", async (queueName, jobName, jobData) => {\n//     if (!queues[queueName]) {\n//         queues[queueName] = await new Queue(queueName, { connection });\n//         eventQueues[queueName] = await new QueueEvents(queueName, { connection });\n//     };\n//     var job = await queues[queueName].add(jobName, jobData);\n//     const result = await job.waitUntilFinished(eventQueues[queueName]);\n//     return result\n    \n// })",
        "finalize": "",
        "libs": [
            {
                "var": "bullmq",
                "module": "bullmq"
            },
            {
                "var": "ioredis",
                "module": "ioredis"
            }
        ],
        "x": 960,
        "y": 1200,
        "wires": [
            []
        ]
    },
    {
        "id": "a57bb6acb1448026",
        "type": "inject",
        "z": "c23a997595de5280",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": "5",
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 60,
        "y": 720,
        "wires": [
            [
                "f6fef070f56d7e96"
            ]
        ]
    },
    {
        "id": "3aef1603dfd298a1",
        "type": "subflow:52dd62cdb44e91b4",
        "z": "c23a997595de5280",
        "name": "",
        "x": 240,
        "y": 780,
        "wires": [
            [],
            [
                "1b18fe7921f013da"
            ]
        ]
    },
    {
        "id": "f6fef070f56d7e96",
        "type": "function",
        "z": "c23a997595de5280",
        "name": "Listening Tables",
        "func": "msg.payload = {};\nnode.status({ fill: \"red\", shape: \"ring\", text: \"Starting\" });\nmsg.payload.graphQlData = {\n    schema: 'private',\n    operationName: \"new_data\",\n    query: `\n              query List_table($where: ModeltableWhereInput) {\n                    list_table(where: $where) { id createdAt updatedAt name schema getter setter columns:list_column {\n                        id, type, required, is_many, name, relations:list_relation {\n                            field, reference\n                    }}}}`,\n    variables: {\n        \"where\": {\n            \"schema\": {\n            // \"_in\": [\"dev\", \"app\", \"auth\", \"style\", \"cloud\"]\n            // \"_in\": [\"dev\"]\n            }\n        }\n        }\n};\nnode.status({ fill: \"red\", shape: \"ring\", text: \"Running\" });\n\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "fs",
                "module": "fs"
            }
        ],
        "x": 240,
        "y": 720,
        "wires": [
            [
                "3aef1603dfd298a1"
            ]
        ]
    },
    {
        "id": "1b18fe7921f013da",
        "type": "function",
        "z": "c23a997595de5280",
        "name": "Flat Tables",
        "func": "var list_table = msg.payload.new_data.data.list_table;\nvar schemaList = [ ...new Set(list_table.map( ({schema}) => schema))] ;\nvar schemaMap = schemaList.map( (schema) => {\n    return [ schema, list_table.filter( ({ schema:schemaInTable }) => schema == schemaInTable)]\n});\nmsg.topic = \"configTables\";\nmsg.payload = schemaMap;\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 250,
        "y": 840,
        "wires": [
            [
                "96096491ed2e468c"
            ]
        ]
    },
    {
        "id": "3c6f249dee200bfb",
        "type": "function",
        "z": "c23a997595de5280",
        "name": "Query Worker",
        "func": "global.get(\"setWorker\")(\"ws\", (job) => {\n    node.send({\n        topic: \"request\",\n        request: job.data\n    })\n    return null\n}, { concurrency: 100 })\nreturn null;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 320,
        "y": 320,
        "wires": [
            [
                "96096491ed2e468c"
            ]
        ]
    },
    {
        "id": "e0ff351aab7170b9",
        "type": "function",
        "z": "c23a997595de5280",
        "name": "Convert Mutation To Hasura",
        "func": "let { mode, action, objectQuery, context: contextValue, resolveNow } = msg.payload;\nconsole.log(mode, action, objectQuery)\ntry {\n    node.send([{\n        topic: \"parse\",\n        payload: await context.get(\"queryNow\")( contextValue.id, mode, action, objectQuery, true),\n        type: \"start\",\n        mode,\n        objectQuery,\n        action,\n        contextValue,\n        resolveNow\n    }])\n    node.status({\n        fill: \"green\",\n        shape: \"ring\",\n        text: contextValue.id\n    })\n} catch (err) {\n    console.log(err.message)\n}\nreturn null;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "const { createId } = paralleldriveCuid2;\n\nconst filterPrismaToHasuraInWhere = new Map([\n     [\"neq\", [\"_neq\"]],\n     [\"eq\", [\"_eq\"]],\n     [\"equals\", [\"_eq\"]],\n     [\"lte\", [\"[_lte\"]],\n     [\"lt\", [\"_lt\"]],\n     [\"gte\", [\"_gte\"]],\n     [\"gt\", [\"_gt\"]],\n     [\"in\", [\"_in\"]],\n     [\"notIn\", [\"_nin\"]],\n     [\"like\", [\"_like\"]],\n     [\"iLike\", [\"_ilike\"]],\n     [\"regex\", [\"_regex\"]],\n     [\"iRegex\", [\"_iregex\"]],\n     [\"hasKey\", [\"_has_key\"]],\n     [\"isNull\", [\"_is_null\"]],\n ]);\n\nconst filterPrismaToHasura = new Map([\n       [\"neq\", [\"_neq\"]],\n       [\"eq\", [\"_eq\"]],\n       [\"equals\", [\"_eq\"]],\n       [\"lte\", [\"[_lte\"]],\n       [\"lt\", [\"_lt\"]],\n       [\"gte\", [\"_gte\"]],\n       [\"gt\", [\"_gt\"]],\n       [\"in\", [\"_in\"]],\n       [\"notIn\", [\"_nin\"]],\n       [\"like\", [\"_like\"]],\n       [\"iLike\", [\"_ilike\"]],\n       [\"regex\", [\"_regex\"]],\n       [\"iRegex\", [\"_iregex\"]],\n       [\"and\", [\"_and\"]],\n       [\"or\", [\"_or\"]],\n       [\"not\", [\"_not\"]],\n       [\"distinctOn\", [\"distinct_on\"]],\n       [\"orderBy\", [\"order_by\"]],\n       [\"hasKey\", [\"_has_key\"]],\n       [\"cast\", [\"_cast\"]],\n       [\"String\", [\"String\"]],\n       [\"path\", [\"path\"]],\n   ]);\n\nconst generatedHasuraVariables = (objectQuery, type = undefined, zone = '', level = '') => {\n    // objectQuery.variables.where = { and: [objectQuery.variables.where || {}, { deletedAt: { isNull: true } }] }\n    let generatedHasuraVariablesZone = (variables, type = undefined) => {\n        return Object.fromEntries(Object.entries(variables).map(([key, val]) => {\n            let test_key = filterPrismaToHasuraInWhere.get(key);\n            if (test_key) {\n                return [test_key, val]\n            } else {\n                let _type = type || key;\n                let new_key = [...filterPrismaToHasura.get(key) || [key]][0];\n                if (val && [\"and\", \"or\", \"not\"].includes(key) && Object.prototype.toString.call(val) === '[object Array]') {\n                    return [new_key, val.map(_val => generatedHasuraVariablesZone(_val, _type))]\n                } else if (val && !filterPrismaToHasuraInWhere.has(key) && Object.prototype.toString.call(val) === '[object Object]') {\n                    if (new_key.startsWith(\"list\")) {\n                        return [new_key, generatedHasuraVariablesZone({ and: [{ deletedAt: { isNull: true } }, val] }, _type)]\n                    } else {\n                        return [new_key, generatedHasuraVariablesZone(val, _type)]\n                    }\n                } else {\n                    return [new_key, val]\n                }\n            }\n        }))\n    }\n    return Object.fromEntries([...Object.entries(generatedHasuraVariablesZone(objectQuery.variables)).map(([key, val]) => [`${key}_${zone}_${level}`, val]),\n    ...objectQuery.links.map((childQuery, childQueryIndex) => Object.entries(generatedHasuraVariables(childQuery, undefined, `${zone}${level}`, childQueryIndex))).flat()\n    ])\n}\n\nconst target_begin = {\n    get: ``,\n    list: ``,\n    aggregate: ``,\n    create: 'insert_',\n    update: \"update_\",\n    delete: \"delete_\"\n}\n\nconst target_end = {\n    get: ``,\n    list: ``,\n    aggregate: `_aggregate`,\n    create: '_one',\n    update: \"_by_pk\",\n    delete: \"_by_pk\"\n}\n\nconst generatedHasuraQuery = (type, action, objectQuery, root = true, zone = '', level = '') => {\n\n    return `${([\"socket\", \"subscription\"].includes(type)) ? `${[...objectQuery.target].shift()}:` : (root ? \"data:\" : \"\")}${objectQuery.schema ? `${root ? `${target_begin[action]}${objectQuery.schema}_` : \"\"}${objectQuery.target.slice(-1)}${target_end[action]}` : objectQuery.target.slice(-1)[0]}\n    ${Object.keys(objectQuery.variables).length > 0 ? `(${(() => {\n            let trans_variables = Object.keys(objectQuery.variables).map(k => (filterPrismaToHasura.get(k) || [k])[0]);\n            return [\n                [\"where\", `$where_${zone}_${level}`],\n                [\"order_by\", `$order_by_${zone}_${level}`],\n                [\"distinct_on\", `$distinct_on_${zone}_${level}`],\n                [\"limit\", `$limit_${zone}_${level}`],\n                [\"offset\", `$offset_${zone}_${level}`],\n                [\"createInput\", `$createInput_${zone}_${level}`, \"object\"],\n                [\"updateInput\", `$updateInput_${zone}_${level}`, \"_set\"],\n                [\"pk_columns\", `$pk_columns_${zone}_${level}`],\n                [\"id\", `$id_${zone}_${level}`]\n            ].filter(([key, val]) => trans_variables.includes(key)).map(([originKey, newVal, newKey]) => `${newKey || originKey}: ${newVal}`).join(\", \")\n\n        })()\n            })` : \"\"} {\n            ${objectQuery.fields.map((x) => `${(x.length > 1 && [\"socket\", \"subscription\", \"mutation\"].includes(type)) ? `${x.slice(0, 1)[0]}:` : \"\"}${x.slice(-1)[0]}`).join(\"\\n\")}\n            ${objectQuery.links.map((x, linkIndex) => generatedHasuraQuery(type, action, x, false, `${zone}${level}`, linkIndex))}\n        }`;\n}\n\nconst generateHasuraVariablesType = (objectQuery, zone = '', level = '') => {\n    let table = `${objectQuery.schema}_${[...objectQuery.target].pop().replace(\"list_\", \"\")}`\n    let keys = Object.keys(objectQuery.variables).map(k => (filterPrismaToHasura.get(k) || [k])[0]);\n    let tt = [...[\n        [\"where\", `${table}_bool_exp!`],\n        [\"order_by\", `[${table}_order_by!]`],\n        [\"distinct_on\", `[${table}_select_column!]`],\n        [\"updateInput\", `${table}_set_input`],\n        [\"createInput\", `${table}_insert_input!`],\n        [\"limit\", `Int`],\n        [\"offset\", `Int`],\n        [\"pk_columns\", `${table}_pk_columns_input!`],\n        [\"id\", `String!`]\n    ].filter(([key, val]) => keys.includes(key)).map(([key, val]) => `$${key}_${zone}_${level}: ${val}`),\n    ...objectQuery.links.map((childQuery, childQueryIndex) => generateHasuraVariablesType(childQuery, `${zone}${level}`, childQueryIndex))\n    ]\n    return tt.filter(x => x).join(\",\")\n}\n\nconst generateHasuraObject = (id, mode, action, objectQuery, root = true) => {\n    switch (action) {\n        case \"create\":\n            objectQuery.variables[\"createInput\"] = objectQuery.variables.input;\n            delete objectQuery.variables.input;\n            break;\n        case \"update\":\n            objectQuery.variables[\"pk_columns\"] = { id: objectQuery.variables.id };\n            delete objectQuery.variables.id;\n            objectQuery.variables[\"updateInput\"] = objectQuery.variables.input;\n            delete objectQuery.variables.input;\n            break;\n        case \"delete\":\n            break;\n        default:\n            if (objectQuery.variables.id) {\n                objectQuery.variables[\"where\"] = objectQuery.variables[\"where\"] || {};\n                objectQuery.variables[\"where\"][\"id\"] = { _eq: objectQuery.variables.id };\n                delete objectQuery.variables.id;\n            };\n            break;\n    }\n    console.log(JSON.stringify(objectQuery.variables))\n    \n    let table = `${objectQuery.schema}_${objectQuery.target.slice(-1)[0]}`\n    let _variables = generatedHasuraVariables(objectQuery);\n    let _variablesType = generateHasuraVariablesType(objectQuery);\n    let _query = generatedHasuraQuery(mode, action, objectQuery);\n    console.log(mode, action)\n    return ({\n        query: `${mode === \"socket\" ? \"subscription\" : mode } ${id}${_variablesType ? ` (${_variablesType}) ` : \"\"}{ ${_query} }`,\n        variables: _variables\n    })\n}\n\nconst applyRole = async (action, objectQuery) => {\n    objectQuery.user = {};\n    if (objectQuery.headers['authorization'] && objectQuery.headers['authorization']['startsWith'](\"Bearer \")) {\n        let token = objectQuery.headers['authorization'].slice(7)\n        let payload = jwt.verify(token, await jwt.getPrivateKey(), { algorithm: \"HS512\" })\n        objectQuery.user['id'] = payload.userId;\n    }\n\n    objectQuery.links.map(childObjectQuery => applyRole(action, Object.assign(childObjectQuery, { headers: objectQuery.headers })))\n    if ([\"get\", \"list\"].includes(action)) {\n    //     if (objectQuery.variables.id) {\n    //         objectQuery.variables[\"where\"] = objectQuery.variables[\"where\"] || {};\n    //         objectQuery.variables[\"where\"][\"id\"] = { _eq: objectQuery.variables.id };\n    //         delete objectQuery.variables.id;\n    //     }\n    //     let getter = getters.get(objectQuery.target[1])\n    //     if (getter) {\n    //         await getter.bind(objectQuery)()\n    //     }\n    } else if ([\"create\", \"update\"].includes(action)) {\n        // let setter = setters.get(objectQuery.target[1]);\n        // if (setter) {\n        //     await setter.bind(objectQuery)()\n        // }\n    }\n    return objectQuery\n}\n\nconst queryNow = async (id, mode, action, objectQuery, socket = false, callback = () => { }) => {\n    id = id || createId()\n    objectQuery = await applyRole(action, objectQuery) || objectQuery;\n    let _query2 = generateHasuraObject(id, mode, action, objectQuery);\n    return _query2\n    // await sendData(id, { operationName: id, ..._query2 }, \"start\");\n    // return await new Promise((resolve, reject) => {\n    //     emitter.once(id, async (_preDeleteRecord) => {\n    //         resolve(_preDeleteRecord)\n    //     })\n    // })\n};\ncontext.set(\"queryNow\", queryNow)",
        "finalize": "",
        "libs": [
            {
                "var": "paralleldriveCuid2",
                "module": "@paralleldrive/cuid2"
            },
            {
                "var": "jwt",
                "module": "jsonwebtoken"
            }
        ],
        "x": 380,
        "y": 1260,
        "wires": [
            [
                "5bdc419d149273cc"
            ]
        ]
    },
    {
        "id": "fbf31049b3497eb8",
        "type": "inject",
        "z": "c23a997595de5280",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 150,
        "y": 160,
        "wires": [
            [
                "416613921c0756e4",
                "8a05d71c94fe98cd",
                "b9b4c4e96a7fc381"
            ]
        ]
    },
    {
        "id": "d906448b3abaf1fa",
        "type": "delay",
        "z": "c23a997595de5280",
        "name": "",
        "pauseType": "delay",
        "timeout": "5",
        "timeoutUnits": "seconds",
        "rate": "1",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": false,
        "allowrate": false,
        "outputs": 1,
        "x": 220,
        "y": 640,
        "wires": [
            [
                "f6fef070f56d7e96"
            ]
        ]
    },
    {
        "id": "5fad62146d4956ef",
        "type": "switch",
        "z": "c23a997595de5280",
        "name": "",
        "property": "payload.mode",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "query",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "subscription",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "mutation",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 3,
        "x": 70,
        "y": 1160,
        "wires": [
            [
                "8b4ef052d350767e"
            ],
            [
                "3b1f1287e267f61f"
            ],
            [
                "e0ff351aab7170b9"
            ]
        ]
    },
    {
        "id": "dcb5b25e757dd707",
        "type": "function",
        "z": "c23a997595de5280",
        "name": "Query Worker",
        "func": "global.get(\"setWorker\")(\"socket\", (job) => {\n    node.send({\n        topic: \"request\",\n        request: job.data\n    });\n    node.status({fill:\"green\",shape:\"ring\",text:job.jobId});\n    return null\n}, { concurrency: 100 })\nreturn null;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 320,
        "y": 260,
        "wires": [
            [
                "96096491ed2e468c"
            ]
        ]
    },
    {
        "id": "3b1f1287e267f61f",
        "type": "function",
        "z": "c23a997595de5280",
        "name": "Convert Subscription To Hasura",
        "func": "let { mode, action, objectQuery, context: contextValue, resolveNow } = msg.payload;\nconsole.log('convert', mode, action)\ntry {\n    node.send([{\n        topic: \"parse\",\n        payload: await context.get(\"queryNow\")( contextValue.id, mode, action, objectQuery, true),\n        type: \"start\",\n        objectQuery,\n        mode,\n        action,\n        contextValue,\n        resolveNow\n    }])\n    node.status({\n        fill: \"green\",\n        shape: \"ring\",\n        text: contextValue.id\n    })\n} catch (err) {\n    console.log(err.message)\n}\nreturn null;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "const { createId } = paralleldriveCuid2;\n\nconst filterPrismaToHasuraInWhere = new Map([\n     [\"neq\", [\"_neq\"]],\n     [\"eq\", [\"_eq\"]],\n     [\"equals\", [\"_eq\"]],\n     [\"lte\", [\"[_lte\"]],\n     [\"lt\", [\"_lt\"]],\n     [\"gte\", [\"_gte\"]],\n     [\"gt\", [\"_gt\"]],\n     [\"in\", [\"_in\"]],\n     [\"notIn\", [\"_nin\"]],\n     [\"like\", [\"_like\"]],\n     [\"iLike\", [\"_ilike\"]],\n     [\"regex\", [\"_regex\"]],\n     [\"iRegex\", [\"_iregex\"]],\n     [\"hasKey\", [\"_has_key\"]],\n     [\"isNull\", [\"_is_null\"]],\n ]);\n\nconst filterPrismaToHasura = new Map([\n       [\"neq\", [\"_neq\"]],\n       [\"eq\", [\"_eq\"]],\n       [\"equals\", [\"_eq\"]],\n       [\"lte\", [\"[_lte\"]],\n       [\"lt\", [\"_lt\"]],\n       [\"gte\", [\"_gte\"]],\n       [\"gt\", [\"_gt\"]],\n       [\"in\", [\"_in\"]],\n       [\"notIn\", [\"_nin\"]],\n       [\"like\", [\"_like\"]],\n       [\"iLike\", [\"_ilike\"]],\n       [\"regex\", [\"_regex\"]],\n       [\"iRegex\", [\"_iregex\"]],\n       [\"and\", [\"_and\"]],\n       [\"or\", [\"_or\"]],\n       [\"not\", [\"_not\"]],\n       [\"distinctOn\", [\"distinct_on\"]],\n       [\"orderBy\", [\"order_by\"]],\n       [\"hasKey\", [\"_has_key\"]],\n       [\"cast\", [\"_cast\"]],\n       [\"String\", [\"String\"]],\n       [\"path\", [\"path\"]],\n   ]);\n\nconst generatedHasuraVariables = (objectQuery, type = undefined, zone = '', level = '') => {\n    objectQuery.variables.where = { and: [objectQuery.variables.where || {}, { deletedAt: { isNull: true } }] }\n    let generatedHasuraVariablesZone = (variables, type = undefined) => {\n        return Object.fromEntries(Object.entries(variables).map(([key, val]) => {\n            let test_key = filterPrismaToHasuraInWhere.get(key);\n            if (test_key) {\n                return [test_key, val]\n            } else {\n                let _type = type || key;\n                let new_key = [...filterPrismaToHasura.get(key) || [key]][0];\n                if (val && [\"and\", \"or\", \"not\"].includes(key) && Object.prototype.toString.call(val) === '[object Array]') {\n                    return [new_key, val.map(_val => generatedHasuraVariablesZone(_val, _type))]\n                } else if (val && !filterPrismaToHasuraInWhere.has(key) && Object.prototype.toString.call(val) === '[object Object]') {\n                    if (new_key.startsWith(\"list\")) {\n                        return [new_key, generatedHasuraVariablesZone({ and: [{ deletedAt: { isNull: true } }, val] }, _type)]\n                    } else {\n                        return [new_key, generatedHasuraVariablesZone(val, _type)]\n                    }\n                } else {\n                    return [new_key, val]\n                }\n            }\n        }))\n    }\n    return Object.fromEntries([...Object.entries(generatedHasuraVariablesZone(objectQuery.variables)).map(([key, val]) => [`${key}_${zone}_${level}`, val]),\n    ...objectQuery.links.map((childQuery, childQueryIndex) => Object.entries(generatedHasuraVariables(childQuery, undefined, `${zone}${level}`, childQueryIndex))).flat()\n    ])\n}\n\nconst target_begin = {\n    get: ``,\n    list: ``,\n    aggregate: ``,\n    create: 'insert_',\n    update: \"update_\"\n}\n\nconst target_end = {\n    get: ``,\n    list: ``,\n    aggregate: `_aggregate`,\n    create: '_one',\n    update: \"_by_pk\"\n}\n\nconst generatedHasuraQuery = (type, action, objectQuery, root = true, zone = '', level = '') => {\n    return `${([\"socket\", \"subscription\"].includes(type)) ? `${[...objectQuery.target].shift()}:` : (root ? \"data:\" : \"\")}${objectQuery.schema ? `${root ? `${objectQuery.schema}_` : \"\"}${objectQuery.target.slice(-1)}${target_end[action]}` : objectQuery.target.slice(-1)[0]}\n    ${Object.keys(objectQuery.variables).length > 0 ? `(${(() => {\n            let trans_variables = Object.keys(objectQuery.variables).map(k => (filterPrismaToHasura.get(k) || [k])[0]);\n            return [\n                [\"where\", `$where_${zone}_${level}`],\n                [\"order_by\", `$order_by_${zone}_${level}`],\n                [\"distinct_on\", `$distinct_on_${zone}_${level}`],\n                [\"limit\", `$limit_${zone}_${level}`],\n                [\"offset\", `$offset_${zone}_${level}`],\n            ].filter(([key, val]) => trans_variables.includes(key)).map((x) => x.join(\": \")).join(\", \")\n\n        })()\n            })` : \"\"} {\n            ${objectQuery.fields.map((x) => `${(x.length > 1 && [\"socket\", \"subscription\"].includes(type)) ? `${x.slice(0, 1)[0]}:` : \"\"}${x.slice(-1)[0]}`).join(\"\\n\")}\n            ${objectQuery.links.map((x, linkIndex) => generatedHasuraQuery(type, action, x, false, `${zone}${level}`, linkIndex))}\n        }`;\n}\n\nconst generateHasuraVariablesType = (objectQuery, zone = '', level = '') => {\n    let table = `${objectQuery.schema}_${[...objectQuery.target].pop().replace(\"list_\", \"\")}`\n    let keys = Object.keys(objectQuery.variables).map(k => (filterPrismaToHasura.get(k) || [k])[0]);\n    let tt = [...[\n        [\"where\", `${table}_bool_exp`],\n        [\"order_by\", `[${table}_order_by!]`],\n        [\"distinct_on\", `[${table}_select_column!]`],\n        [\"limit\", `Int`],\n        [\"offset\", `Int`],\n    ].filter(([key, val]) => keys.includes(key)).map(([key, val]) => `$${key}_${zone}_${level}: ${val}`),\n    ...objectQuery.links.map((childQuery, childQueryIndex) => generateHasuraVariablesType(childQuery, `${zone}${level}`, childQueryIndex))\n    ]\n    return tt.filter(x => x).join(\",\")\n}\n\nconst generateHasuraObject = (id, mode, action, objectQuery, root = true) => {\n    if (objectQuery.variables.id) {\n        objectQuery.variables[\"where\"] = objectQuery.variables[\"where\"] || {};\n        objectQuery.variables[\"where\"][\"id\"] = { _eq: objectQuery.variables.id };\n        delete objectQuery.variables.id;\n    }\n\n    let table = `${objectQuery.schema}_${objectQuery.target.slice(-1)[0]}`\n    let _variables = generatedHasuraVariables(objectQuery);\n    let _variablesType = generateHasuraVariablesType(objectQuery);\n    let _query = generatedHasuraQuery(mode, action, objectQuery);\n\n    return ({\n        query: `${mode === \"subscription\" ? mode : \"query\"} ${id}${_variablesType ? ` (${_variablesType}) ` : \"\"}{ ${_query} }`,\n        variables: _variables\n    })\n}\n\nconst applyRole = async (action, objectQuery) => {\n    // objectQuery.user = {};\n    // if (objectQuery.headers['authorization'] && objectQuery.headers['authorization']['startsWith'](\"Bearer \")) {\n    //     let token = objectQuery.headers['authorization'].slice(7)\n    //     let payload = jwt.verify(token, await jwt.getPrivateKey(), { algorithm: \"HS512\" })\n    //     objectQuery.user['id'] = payload.userId;\n    // }\n\n    objectQuery.links.map(childObjectQuery => applyRole(action, Object.assign(childObjectQuery, { headers: objectQuery.headers })))\n    // if ([\"get\", \"list\"].includes(action)) {\n    //     if (objectQuery.variables.id) {\n    //         objectQuery.variables[\"where\"] = objectQuery.variables[\"where\"] || {};\n    //         objectQuery.variables[\"where\"][\"id\"] = { _eq: objectQuery.variables.id };\n    //         delete objectQuery.variables.id;\n    //     }\n    //     let getter = getters.get(objectQuery.target[1])\n    //     if (getter) {\n    //         await getter.bind(objectQuery)()\n    //     }\n    // } else if ([\"create\", \"update\"].includes(action)) {\n    //     let setter = setters.get(objectQuery.target[1]);\n    //     if (setter) {\n    //         await setter.bind(objectQuery)()\n    //     }\n    // }\n    return objectQuery\n}\n\nconst queryNow = async (id, mode, action, objectQuery, socket = false, callback = () => { }) => {\n    id = id || createId()\n    objectQuery = await applyRole(action, objectQuery) || objectQuery;\n    let _query2 = generateHasuraObject(id, socket ? \"subscription\" : \"query\", action, objectQuery);\n    return _query2\n    // await sendData(id, { operationName: id, ..._query2 }, \"start\");\n    // return await new Promise((resolve, reject) => {\n    //     emitter.once(id, async (_preDeleteRecord) => {\n    //         resolve(_preDeleteRecord)\n    //     })\n    // })\n};\ncontext.set(\"queryNow\", queryNow)",
        "finalize": "",
        "libs": [
            {
                "var": "paralleldriveCuid2",
                "module": "@paralleldrive/cuid2"
            },
            {
                "var": "jwt",
                "module": "jsonwebtoken"
            }
        ],
        "x": 390,
        "y": 1200,
        "wires": [
            [
                "5bdc419d149273cc"
            ]
        ]
    },
    {
        "id": "416613921c0756e4",
        "type": "function",
        "z": "c23a997595de5280",
        "name": "Start Emitter",
        "func": "( async () => {\n    await node.status({\n        fill: \"red\",\n        shape: \"ring\",\n        text: \"Starting\"\n    })\n    await context.get(\"init\")()\n    await node.status({\n        fill: \"red\",\n        shape: \"ring\",\n        text: \"Running\"\n    });\n\n    node.send({})\n})()\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "var createId = paralleldriveCuid2;\nvar { EventEmitter } = events;\n\nvar __local = new Proxy({\n    __emitter: new EventEmitter(),\n    __emitterContainer: {},\n    __emitterKeys: {},\n    _once: async function (event_name, funcOn, config = false, keyOn = null) {\n        if (!this.__emitterKeys[event_name]) { this.__emitterKeys[event_name] = createId() }\n        let { key, init, resolve } = Object.assign({ init: false, key: keyOn || createId() }, config.constructor === Object ? config : ({ init: config }));\n        if (!this.__emitterContainer[event_name]) {\n            this.__emitterContainer[event_name] = new Map();\n        }\n        this.__emitterContainer[event_name].set(key, funcOn);\n        if (init) { funcOn() }\n        // console.log(\"keyOn\", key, init)\n        this.__emitter.once(this.__emitterKeys[event_name], async ({ value, keyApply: keyEmit }) => {\n            // console.log(\"keyEmit\", keyEmit)\n            this.__emitter.emit(keyEmit, { status: \"init\" });\n            let returnData = await funcOn(value);\n            this.__emitter.emit(keyEmit, { status: \"complete\", payload: returnData })\n        })\n    },\n    _on: async function (event_name, funcOn, config = false, keyOn = null) {\n        if (!this.__emitterKeys[event_name]) { this.__emitterKeys[event_name] = createId() }\n        let { key, init } = Object.assign({ init: false, key: keyOn || createId() }, config.constructor === Object ? config : ({ init: config }));\n        if (!this.__emitterContainer[event_name]) {\n            this.__emitterContainer[event_name] = new Map();\n        }\n        this.__emitterContainer[event_name].set(key, funcOn);\n        if (init) { await funcOn(this[event_name]) }\n        // console.log(\"keyOn\", key, init)\n        this.__emitter.on(this.__emitterKeys[event_name], async ({ value, keyApply: keyEmit, replyTo }) => {\n            // console.log(\"keyEmit\", keyEmit)\n            this.__emitter.emit(keyEmit, { status: \"init\" });\n            let returnData = await funcOn(value);\n            this.__emitter.emit(keyEmit, { status: \"complete\", payload: returnData })\n        })\n    },\n    _emit: async function (event_name, value, config = false) {\n        if (!this.__emitterKeys[event_name]) { this.__emitterKeys[event_name] = createId() }\n        let { confirm, async, replyTo } = Object.assign({ confirm: false, async: true }, config.constructor === Object ? config : { confirm: config });\n        if (confirm) { this[event_name] = value }\n        return new Promise((resolve, reject) => {\n            let keyApply = createId();\n            if (async) {\n                var [onLength, hasListener] = [0, false];\n                this.__emitter.on(keyApply, ({ status, payload }) => {\n                    if (status === \"init\") { onLength++, hasListener = true }\n                    if (status === \"complete\") { onLength-- }\n                    // console.log(\"keyLength\", onLength)\n                    if (!onLength) { resolve(payload) }\n                });\n                setTimeout(() => { if (!hasListener) { resolve() } }, 100)\n            }\n            this.__emitter.emit(this.__emitterKeys[event_name], { value, keyApply, replyTo });\n            this.__emitter.emit(event_name, value);\n            if (!async) { resolve() }\n        })\n    }\n}, {\n    set(target, prop, value) { target[prop] = value; return true },\n    get(target, prop) { return target[prop] }\n});\n\ncontext.set(\"init\", async () => {\n    __local.__emitter.setMaxListeners(0);\n    await flow.set(\"emitter\", __local.__emitter);\n    await flow.set(\"_emit\", __local._emit);\n    await flow.set(\"_on\", __local._on);\n    await flow.set(\"_once\", __local._once);\n    \n})",
        "finalize": "",
        "libs": [
            {
                "var": "events",
                "module": "events"
            },
            {
                "var": "paralleldriveCuid2",
                "module": "@paralleldrive/cuid2"
            }
        ],
        "x": 370,
        "y": 40,
        "wires": [
            [
                "b07817c85e5e8aca"
            ]
        ],
        "icon": "node-red/arrow-in.svg"
    },
    {
        "id": "b07817c85e5e8aca",
        "type": "join",
        "z": "c23a997595de5280",
        "name": "Compile",
        "mode": "custom",
        "build": "array",
        "property": "",
        "propertyType": "full",
        "key": "topic",
        "joiner": "\\n",
        "joinerType": "str",
        "useparts": true,
        "accumulate": false,
        "timeout": "",
        "count": "3",
        "reduceRight": false,
        "reduceExp": "",
        "reduceInit": "",
        "reduceInitType": "num",
        "reduceFixup": "",
        "x": 630,
        "y": 160,
        "wires": [
            [
                "1c6257e13a59aa4f"
            ]
        ]
    },
    {
        "id": "b9b4c4e96a7fc381",
        "type": "subflow:5ed478d1a62e4007",
        "z": "c23a997595de5280",
        "name": "",
        "x": 390,
        "y": 160,
        "wires": [
            [
                "b07817c85e5e8aca"
            ]
        ]
    },
    {
        "id": "8a05d71c94fe98cd",
        "type": "subflow:1e273549eda8541e",
        "z": "c23a997595de5280",
        "name": "",
        "env": [
            {
                "name": "REDIS_CONNECTION",
                "value": "REDIS_CONNECTION",
                "type": "env"
            }
        ],
        "x": 390,
        "y": 100,
        "wires": [
            [
                "b07817c85e5e8aca"
            ]
        ]
    },
    {
        "id": "1c6257e13a59aa4f",
        "type": "function",
        "z": "c23a997595de5280",
        "name": "function 4",
        "func": "flow.set(\"setWorker\", global.get(\"setWorker\"));\nflow.set(\"getQueue\", global.get(\"getQueue\"));\nflow.set(\"sendJobToQueue\", global.get(\"sendJobToQueue\"));\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 800,
        "y": 160,
        "wires": [
            [
                "46ec6a406cbcd841"
            ]
        ]
    },
    {
        "id": "46ec6a406cbcd841",
        "type": "function",
        "z": "c23a997595de5280",
        "name": "Soc Query",
        "func": " \nvar emitter = new events.EventEmitter();\nemitter.setMaxListeners(0);\n\nlet returnQueue = 'http-response-' + paralleldriveCuid2.createId();\n\nconst app = flow.get(\"webApp\");\n\nvar addJob = await global.get(\"getQueue\")(\"query\"); \nawait node.status({\n        fill: \"red\",\n        shape: \"ring\",\n        text: \"Starting at: \" + new Date()\n    });\n\nconst processRequest = async function (schema, socFunc, callback = () => {}) {\n    // return await new Promise( async (resolve, reject) => {\n        let requestId = paralleldriveCuid2.createId();\n        console.log(\"s\", schema, requestId)\n        node.status({\n            fill: \"red\",\n            shape: \"ring\",\n            text: \"Processing at: \" + new Date() + \" \" + requestId\n        });\n        console.log(\"m\", schema, requestId)\n        await socFunc.bind({}, {\n            query: async (query, variables = {}, callFunc) => {\n                console.log(query, variables)\n                addJob(requestId, {\n                    id: requestId,\n                    schema,\n                    payload: { query, variables },\n                    context: {\n                        headers: {},\n                        id: requestId,\n                        replyTo: returnQueue\n                    }\n                }, { jobId: requestId });\n\n                let { type, payload } = await new Promise( (resolve, reject) => {\n                    emitter.once(requestId, async ({ type, payload }) => {\n                    console.log(\"ss\", schema, requestId, JSON.stringify(payload))\n                        resolve({ type, payload })\n                    });\n                })\n                try {\n                    await callFunc(payload)\n                } catch (err) {\n                    console.log(\"sr\", schema, requestId, err.message)\n                    payload = {\n                            errors: [{\n                                message: err.message\n                            }]\n                    }\n                    node.status({\n                        text: err.message\n                    })\n                }\n                console.log(\"se\", schema, requestId, payload)\n                return\n            }\n        })();\n        console.log(\"fulle\", schema, requestId)\n        return \"tesst\"\n    // })\n};\n\nflow.set(\"soc\", processRequest)\n\nglobal.get(\"setWorker\")(returnQueue, async ( returnJob ) => {\n    emitter.emit( returnJob.name, returnJob.data );\n    return null\n}, { concurrency: 100 })\n\nawait node.status({\n    fill: \"green\",\n    shape: \"ring\",\n    text: \"Running at: \" + new Date()\n});\n\nnode.send({})\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "events",
                "module": "events"
            },
            {
                "var": "paralleldriveCuid2",
                "module": "@paralleldrive/cuid2"
            }
        ],
        "x": 90,
        "y": 260,
        "wires": [
            [
                "3c6f249dee200bfb",
                "8364f1a68ee53433",
                "e70dc72a79fb3b7e",
                "dcb5b25e757dd707"
            ]
        ]
    },
    {
        "id": "628cf31e70219aad",
        "type": "function",
        "z": "c23a997595de5280",
        "name": "Process Setter",
        "func": "try {\n    if (msg.topic == \"parse\") {\n        console.log(\"startp\", msg.payload.objectQuery.variables);\n        let payload = msg.payload;\n        node.status({fill:\"green\",shape:\"ring\",text:\"Processing table: \" + payload.objectQuery.target.join(\", \")});\n        await context.get(\"processObjectQuery\")(payload)\n        msg.payload = payload;\n        console.log(\"starte\", msg.payload.objectQuery.variables)\n        node.send(msg);\n    } else if ( msg.topic == \"configTables\") {\n        msg.payload.forEach( async ([schema, tables]) => {\n            node.status({fill:\"red\",shape:\"ring\",text:\"Setting schema: \" + schema});\n            await context.get(\"processTablesInSchema\")(schema, tables);\n            node.status({fill:\"blue\",shape:\"ring\",text:\"Setuped schema: \" + schema});\n        });\n        node.send(msg);\n    }\n} catch (err) {\n    console.log(err)\n}\n\n\nreturn null;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 7,
        "initialize": "const { EventEmitter } = events;\nconst { createId } = paralleldriveCuid2;\nconst bcrypt = bcryptContainer;\nconst getSoc = () => flow.get(\"soc\");\nvar jwt = jsonwebtoken;\njwt.getPrivateKey = async () => \"fgkkhkafdshgkhjfg6875a86768dfkldsfklfhlKHGGKJHkdkfgsldkglKGlkg\";\nconst emitter = new EventEmitter();\nemitter.setMaxListeners(0);\nconst AsyncFunction = (async function () { }).constructor;\nconst defind = \"let [modules, $] = arguments; var { bcrypt, soc, jwt } = modules; \";\n\nvar setterMap = new Map();\nvar getterMap = new Map();\n\nconst processTablesInSchema = async (schema, tables) => {\n    await Promise.all(tables.map(async ({ id, setter, getter }) => {\n        try {\n            let func = await new AsyncFunction(defind + `${setter}`).bind({}, {\n                bcrypt, soc: getSoc(), jwt\n            })();\n            setterMap.set(id, func || (() => {}));\n        } catch (err) {\n            setterMap.set(id, () => { })\n        }\n\n        try {\n            let func = await new AsyncFunction(defind + `${getter}`).bind(this, {\n                bcrypt, soc: getSoc(), jwt\n            })();\n            getterMap.set(id, func || (() => { }));\n        } catch (err) {\n            getterMap.set(id, () => { })\n        }\n\n    }));\n};\n\nconst processObjectQuery = async (payload) => {\n    let { objectQuery, context, mode } = payload;\n    try {\n        console.log(\"setter\", setterMap.get(objectQuery.target[1]).toString())\n        console.log(\"getter\", getterMap.get(objectQuery.target[1]).toString())\n        if (mode === \"mutation\") {\n            let resObject = await setterMap.get(objectQuery.target[1]).apply(objectQuery);\n        }\n        let resObject = await getterMap.get(objectQuery.target[1]).apply(objectQuery);\n        return resObject\n    } catch (err) {\n        console.log(\"setterError\", err)\n        context[\"responseNow\"] = {\n            type: \"error\",\n            payload: {\n                'errors': [{\n                    message: err.message\n                }]\n            }\n        }\n        return null\n    }\n};\n\ncontext.set(\"processTablesInSchema\", processTablesInSchema);\ncontext.set(\"processObjectQuery\", processObjectQuery);",
        "finalize": "",
        "libs": [
            {
                "var": "events",
                "module": "events"
            },
            {
                "var": "paralleldriveCuid2",
                "module": "@paralleldrive/cuid2"
            },
            {
                "var": "jsonwebtoken",
                "module": "jsonwebtoken"
            },
            {
                "var": "bcryptContainer",
                "module": "bcrypt"
            }
        ],
        "x": 340,
        "y": 940,
        "wires": [
            [
                "d87f029292a13257"
            ]
        ]
    },
    {
        "id": "79051faa209a98d3",
        "type": "function",
        "z": "c23a997595de5280",
        "name": "resolveValue",
        "func": "let { payload, type, contextValue, mode, action, resolveNow } = msg;\n\nif (resolveNow) {\n    resolveNow(payload.context.responseNow)\n} else {\n    if (payload.context.replyTo) {\n        node.send({\n            topic: \"reply\",\n            returnValue: payload.context.responseNow,\n            replyTo: payload.context.replyTo,\n            id: payload.context.id\n        });\n    }\n}",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 830,
        "y": 980,
        "wires": [
            [
                "455564d6912289d5"
            ]
        ]
    },
    {
        "id": "d87f029292a13257",
        "type": "switch",
        "z": "c23a997595de5280",
        "name": "Check ResponseNow",
        "property": "payload.context.responseNow",
        "propertyType": "msg",
        "rules": [
            {
                "t": "nnull"
            },
            {
                "t": "null"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 2,
        "x": 580,
        "y": 980,
        "wires": [
            [
                "79051faa209a98d3"
            ],
            [
                "5fad62146d4956ef"
            ]
        ]
    },
    {
        "id": "55ba7f6515ca821c",
        "type": "inject",
        "z": "c23a997595de5280",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 620,
        "y": 380,
        "wires": [
            [
                "0ece2d2684448c3d"
            ]
        ]
    },
    {
        "id": "0ece2d2684448c3d",
        "type": "function",
        "z": "c23a997595de5280",
        "name": "function 5",
        "func": "process.env[\"GRAPHQL_URL\"] = \"tessst\";\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "process",
                "module": "process"
            }
        ],
        "x": 860,
        "y": 380,
        "wires": [
            [
                "0eb526b839012358"
            ]
        ]
    },
    {
        "id": "0eb526b839012358",
        "type": "function",
        "z": "c23a997595de5280",
        "name": "function 6",
        "func": "console.log(process.env['GRAPHQL_URL'])\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "process",
                "module": "process"
            }
        ],
        "x": 860,
        "y": 560,
        "wires": [
            []
        ]
    },
    {
        "id": "0cd032db82ea035a",
        "type": "inject",
        "z": "18caed853880999b",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 120,
        "y": 560,
        "wires": [
            [
                "ef317916f434023c",
                "88639a9af1475e4a"
            ]
        ]
    },
    {
        "id": "ef317916f434023c",
        "type": "function",
        "z": "18caed853880999b",
        "d": true,
        "name": "Set MainClient",
        "func": "var { MainClient } = binance;\n\n// or, if you prefer `require()`:\n// const { MainClient } = require('binance');\n\nconst API_KEY = 'xxx';\nconst API_SECRET = 'yyy';\n\nconst client = new MainClient({\n    api_key: \"3XB35QbcNmAfiLHlovMYp3HBcrzlNoXfORUziwFYqgFCQNMkuZke513l12g9kfq5\",\n    api_secret: \"vIA3sbOKI9sXdRVnuIny3y56fuklKTC8XYOtgddrQaz355YrattaFktRa9aDPjZN\",\n    // Connect to testnet environment\n    // testnet: true,\n});\n\nflow.set(\"binance\", client)\n\n// client\n//     .getAccountTradeList({ symbol: 'BTCUSDT' })\n//     .then((result) => {\n//         console.log('getAccountTradeList result: ', result);\n//     })\n//     .catch((err) => {\n//         console.error('getAccountTradeList error: ', err);\n//     });\n\n// client\n//     .getExchangeInfo()\n//     .then((result) => {\n//         console.log('getExchangeInfo inverse result: ', result);\n//     })\n//     .catch((err) => {\n//         console.error('getExchangeInfo inverse error: ', err);\n//     });\nnode.send({})",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "binance",
                "module": "binance"
            }
        ],
        "x": 480,
        "y": 220,
        "wires": [
            [
                "313e5a6a58728ee2"
            ]
        ]
    },
    {
        "id": "313e5a6a58728ee2",
        "type": "function",
        "z": "18caed853880999b",
        "name": "Get price and qty",
        "func": "await new Promise(( resolve, reject) => {\n    flow.get(\"binance\")\n        .getAccountTradeList({ symbol: 'MEMEUSDT' })\n        .then((result) => {\n            node.status({fill:\"red\",shape:\"ring\",text: `${'getAccountTradeList result'}: ${result[0]?.price} - ${result[0]?.qty}`});\n            console.log('getAccountTradeList result: ', result);\n            resolve(null)\n        })\n        .catch((err) => {\n            console.error('getAccountTradeList error: ', err);\n        });\n})\n\n// client\n//     .getExchangeInfo()\n//     .then((result) => {\n//         console.log('getExchangeInfo inverse result: ', result);\n//     })\n//     .catch((err) => {\n//         console.error('getExchangeInfo inverse error: ', err);\n//     });\n\nreturn null",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "binance",
                "module": "binance"
            }
        ],
        "x": 490,
        "y": 320,
        "wires": [
            []
        ]
    },
    {
        "id": "88639a9af1475e4a",
        "type": "function",
        "z": "18caed853880999b",
        "name": "Set USDMClient",
        "func": "var { USDMClient } = binance;\n\n// or, if you prefer `require()`:\n// const { MainClient } = require('binance');\n\nconst API_KEY = 'xxx';\nconst API_SECRET = 'yyy';\n\nconst client = new USDMClient({\n    api_key: \"3XB35QbcNmAfiLHlovMYp3HBcrzlNoXfORUziwFYqgFCQNMkuZke513l12g9kfq5\",\n    api_secret: \"vIA3sbOKI9sXdRVnuIny3y56fuklKTC8XYOtgddrQaz355YrattaFktRa9aDPjZN\",\n    // Connect to testnet environment\n    // testnet: true,\n});\n\nflow.set(\"USDMClient\", client)\n\nclient\n  .getBalance()\n  .then((result) => {\n    console.log('getBalance result: ', result);\n  })\n  .catch((err) => {\n    console.error('getBalance error: ', err);\n  });\n\n// client\n//     .getExchangeInfo()\n//     .then((result) => {\n//         console.log('getExchangeInfo inverse result: ', result);\n//     })\n//     .catch((err) => {\n//         console.error('getExchangeInfo inverse error: ', err);\n//     });\nnode.send({})",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "binance",
                "module": "binance"
            }
        ],
        "x": 400,
        "y": 600,
        "wires": [
            []
        ]
    },
    {
        "id": "939493ad0139f82c",
        "type": "function",
        "z": "18caed853880999b",
        "name": "Submit New Order",
        "func": "await new Promise(( resolve, reject) => {\n    flow.get(\"USDMClient\")\n        .submitNewOrder({\n            side: 'SELL',\n            symbol: 'BTCUSDT',\n            type: 'MARKET',\n            quantity: 0.001,\n        })\n        .then((result) => {\n            console.log('submitNewOrder result: ', result);\n        })\n        .catch((err) => {\n            console.error('submitNewOrder error: ', err);\n        });\n})\n\n// client\n//     .getExchangeInfo()\n//     .then((result) => {\n//         console.log('getExchangeInfo inverse result: ', result);\n//     })\n//     .catch((err) => {\n//         console.error('getExchangeInfo inverse error: ', err);\n//     });\n\nreturn null",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "binance",
                "module": "binance"
            }
        ],
        "x": 690,
        "y": 600,
        "wires": [
            []
        ]
    },
    {
        "id": "44cf2450dae251bd",
        "type": "inject",
        "z": "af13c7f5e79b8c40",
        "name": "Trigger P&L Check",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 140,
        "y": 140,
        "wires": [
            [
                "8bd0dab039326632"
            ]
        ]
    },
    {
        "id": "8bd0dab039326632",
        "type": "function",
        "z": "af13c7f5e79b8c40",
        "name": "1. Set USDMClient",
        "func": "var Binance = binanceApiNode.default;\n\n// ⚠️ THAY THẾ API KEY/SECRET CỦA BẠN TẠI ĐÂY\nconst API_KEY = env.get('BINANCE_APY_KEY');\nconst API_SECRET = env.get('BINANCE_API_SECRET');\n\nconst client = new Binance({\n    apiKey: API_KEY,\n    apiSecret: API_SECRET,\n    // testnet: true, // Bỏ comment nếu dùng testnet\n});\n\nflow.set(\"USDMClient\", client)\n\nmsg.client = client;\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "binanceApiNode",
                "module": "binance-api-node"
            }
        ],
        "x": 390,
        "y": 140,
        "wires": [
            [
                "caf096599c917c0b"
            ]
        ]
    },
    {
        "id": "caf096599c917c0b",
        "type": "function",
        "z": "af13c7f5e79b8c40",
        "name": "2. Get Open Positions & P&L",
        "func": "const client = msg.client;\n\n// Sử dụng getPositionRisk để lấy các vị thế đang mở\n// await client.getPositionRisk()\n//     .then((positions) => {\n//         // Lọc các vị thế có 'positionAmt' khác 0 (vị thế đang mở)\n//         const openPositions = positions.filter(p => parseFloat(p.positionAmt) !== 0);\n        \n//         if (openPositions.length === 0) {\n//             node.warn(\"Không có vị thế đang mở nào.\");\n//             msg.payload = \"Không có vị thế đang mở nào.\";\n//             return msg;\n//         }\n\n//         const results = openPositions.map(p => ({\n//             symbol: p.symbol,\n//             amount: p.positionAmt, // Số lượng (Long/Short)\n//             entryPrice: p.entryPrice, // Giá vào lệnh\n//             markPrice: p.markPrice, // Giá đánh dấu hiện tại\n//             unrealizedProfit: p.unRealizedProfit, // Lãi/Lỗ chưa thực hiện\n//             leverage: p.leverage, // Đòn bẩy\n//             // Các trường khác có thể bao gồm: isolatedWallet, marginType\n//         }));\n\n//         // Log kết quả ra console và payload\n//         console.log('Open Positions with P&L:', results);\n//         msg.payload = results;\n//         node.status({fill:\"green\",shape:\"dot\",text: `Found ${results.length} positions.`});\n//         return msg;\n//     })\n//     .catch((err) => {\n//         node.error('Error getting position risk: ' + err.message, msg);\n//         node.status({fill:\"red\",shape:\"dot\",text: \"API Error\"});\n//         return null; // Không chuyển message đi tiếp khi có lỗi\n//     });\n\nconst c = \"LINKUSDT\"\n\nawait client.futuresMarkPrice({ symbol: c}).then( result => {\n    node.status({fill:\"red\",shape:\"ring\",text:c + \": \" + result['markPrice']});\n})\nconsole.log(await client.futuresAllOrders())\nconsole.log(\n    await client.futuresGetOrder({\n        symbol: 'LINKUSDT',\n        orderId: 44438930210,\n    })\n)\n// Trả về null vì logic chính được xử lý trong Promise/await\nreturn null;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "binance",
                "module": "binance"
            }
        ],
        "x": 680,
        "y": 140,
        "wires": [
            [
                "a8c0b0c9aa71938a"
            ]
        ]
    },
    {
        "id": "a8c0b0c9aa71938a",
        "type": "debug",
        "z": "af13c7f5e79b8c40",
        "name": "Debug Output P&L",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 930,
        "y": 140,
        "wires": []
    },
    {
        "id": "1e55962d365b430a",
        "type": "inject",
        "z": "cdfd4aa9099e0473",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 130,
        "y": 140,
        "wires": [
            [
                "a7c8dada87c5e87c"
            ]
        ]
    },
    {
        "id": "c83add8e12cebe71",
        "type": "debug",
        "z": "cdfd4aa9099e0473",
        "name": "debug 1",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 780,
        "y": 140,
        "wires": []
    },
    {
        "id": "e87c24ce8b7aaad2",
        "type": "ui-button",
        "z": "cdfd4aa9099e0473",
        "group": "c94d49ed7a1ed8f5",
        "name": "",
        "label": "button",
        "order": 4,
        "width": 0,
        "height": 0,
        "emulateClick": false,
        "tooltip": "",
        "color": "",
        "bgcolor": "",
        "className": "",
        "icon": "",
        "iconPosition": "left",
        "payload": "",
        "payloadType": "str",
        "topic": "topic",
        "topicType": "msg",
        "buttonColor": "",
        "textColor": "",
        "iconColor": "",
        "enableClick": true,
        "enablePointerdown": false,
        "pointerdownPayload": "",
        "pointerdownPayloadType": "str",
        "enablePointerup": false,
        "pointerupPayload": "",
        "pointerupPayloadType": "str",
        "x": 430,
        "y": 260,
        "wires": [
            [
                "0c0758552b74ea35"
            ]
        ]
    },
    {
        "id": "0c0758552b74ea35",
        "type": "function",
        "z": "cdfd4aa9099e0473",
        "name": "function 7",
        "func": "msg.payload = \"tesst\"\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 620,
        "y": 200,
        "wires": [
            [
                "b210a09fc5234031",
                "c83add8e12cebe71"
            ]
        ]
    },
    {
        "id": "b210a09fc5234031",
        "type": "ui-text",
        "z": "cdfd4aa9099e0473",
        "group": "c94d49ed7a1ed8f5",
        "order": 3,
        "width": 0,
        "height": 0,
        "name": "",
        "label": "text",
        "format": "{{msg.payload}}",
        "layout": "row-spread",
        "style": false,
        "font": "",
        "fontSize": 16,
        "color": "#717171",
        "wrapText": false,
        "className": "",
        "value": "payload",
        "valueType": "msg",
        "x": 810,
        "y": 340,
        "wires": []
    },
    {
        "id": "a7c8dada87c5e87c",
        "type": "function",
        "z": "cdfd4aa9099e0473",
        "name": "Get env",
        "func": "const AsyncFunction = (async function () { }).constructor;\n\n// let environment = await ejs.compile(\"<%- JSON.stringify(process.env) -%>\", { client: true, async: true, cache: false,  rmWhitespace: false })({  }, null, async (target, d) => {\n//     console.log(JSON.stringify(target))\n//     console.log(JSON.stringify(d))\n//     return target\n\n// });\n\n// console.log(JSON.parse(environment))\n\nmsg.payload = Object.entries(process.env)\n.filter( ([key, value]) => {\n    return key.startsWith(\"TL\")\n})\n.map( ([key, value]) => {\n    return `${key}: ${value}`\n});\nmsg.payload = [ `${'NODE_ENV'}: ${process.env.NODE_ENV}` , ...msg.payload]\nconsole.log(msg)\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "process",
                "module": "process"
            },
            {
                "var": "ejs",
                "module": "ejs"
            }
        ],
        "x": 120,
        "y": 400,
        "wires": [
            [
                "d259e46711f7fdd8"
            ]
        ]
    },
    {
        "id": "d259e46711f7fdd8",
        "type": "ui-template",
        "z": "cdfd4aa9099e0473",
        "group": "c94d49ed7a1ed8f5",
        "page": "",
        "ui": "",
        "name": "",
        "order": 1,
        "width": "6",
        "height": "8",
        "head": "",
        "format": "<template>\n    <div :style=\"green\">\n        <ul style=\"list-style-type: none; padding: 0;\">\n            <div v-for=\"item in msg.payload\">\n                <div>{{ item }}</div>\n            </div>\n        </ul>\n    </div>\n</template>\n\n<script>\n    export default {\n        data() {\n            // define variables available component-wide\n            // (in <template> and component functions)\n            return {\n                html: ''\n            }\n        },\n        watch: {\n            msg: function() {\n                this.html = this.msg.payload\n            },\n            // watch for any changes of \"count\"\n            count: function () {\n                if (this.count % 5 === 0) {\n                    this.send({payload: 'Multiple of 5'})\n                }\n            }\n        },\n        computed: {\n            // automatically compute this variable\n            // whenever VueJS deems appropriate\n            formattedCount: function () {\n                return this.count + ' Apples'\n            }\n        },\n        methods: {\n            // expose a method to our <template> and Vue Application\n            increase: function () {\n                this.count++\n            }\n        },\n        mounted() {\n            this.html = this.msg.payload\n            // code here when the component is first loaded\n        },\n        unmounted() {\n            // code here when the component is removed from the Dashboard\n            // i.e. when the user navigates away from the page\n        }\n    }\n</script>\n<style>\n    /* define any styles here - supports raw CSS */\n    .my-class {\n        color: red;\n    }\n</style>",
        "storeOutMessages": true,
        "passthru": true,
        "resendOnRefresh": true,
        "templateScope": "local",
        "className": "",
        "x": 280,
        "y": 280,
        "wires": [
            []
        ]
    }
]